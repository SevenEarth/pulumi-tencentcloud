// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package security

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to create security group rule.
//
// ## Example Usage
//
// Source is CIDR ip
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Security"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		sglab1Group, err := Security.NewGroup(ctx, "sglab1Group", &Security.GroupArgs{
// 			Description: pulumi.String("favourite sg_1"),
// 			ProjectId:   pulumi.Int(0),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = Security.NewGroupRule(ctx, "sglab1GroupRule", &Security.GroupRuleArgs{
// 			SecurityGroupId: sglab1Group.ID(),
// 			Type:            pulumi.String("ingress"),
// 			CidrIp:          pulumi.String("10.0.0.0/16"),
// 			IpProtocol:      pulumi.String("TCP"),
// 			PortRange:       pulumi.String("80"),
// 			Policy:          pulumi.String("ACCEPT"),
// 			Description:     pulumi.String("favourite sg rule_1"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// Source is a security group id
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/tencentcloudstack/pulumi-tencentcloud/sdk/go/tencentcloud/Security"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		sglab2Group, err := Security.NewGroup(ctx, "sglab2Group", &Security.GroupArgs{
// 			Description: pulumi.String("favourite sg_2"),
// 			ProjectId:   pulumi.Int(0),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		sglab3, err := Security.NewGroup(ctx, "sglab3", &Security.GroupArgs{
// 			Description: pulumi.String("favourite sg_3"),
// 			ProjectId:   pulumi.Int(0),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = Security.NewGroupRule(ctx, "sglab2GroupRule", &Security.GroupRuleArgs{
// 			SecurityGroupId: sglab2Group.ID(),
// 			Type:            pulumi.String("ingress"),
// 			IpProtocol:      pulumi.String("TCP"),
// 			PortRange:       pulumi.String("80"),
// 			Policy:          pulumi.String("ACCEPT"),
// 			SourceSgid:      sglab3.ID(),
// 			Description:     pulumi.String("favourite sg rule_2"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type GroupRule struct {
	pulumi.CustomResourceState

	// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
	AddressTemplate GroupRuleAddressTemplateOutput `pulumi:"addressTemplate"`
	// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
	CidrIp pulumi.StringPtrOutput `pulumi:"cidrIp"`
	// Description of the security group rule.
	Description pulumi.StringOutput `pulumi:"description"`
	// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
	IpProtocol pulumi.StringOutput `pulumi:"ipProtocol"`
	// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
	Policy pulumi.StringOutput `pulumi:"policy"`
	// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
	PortRange pulumi.StringOutput `pulumi:"portRange"`
	// ID of the address template, and conflict with `ipProtocol`, `portRange`.
	ProtocolTemplate GroupRuleProtocolTemplateOutput `pulumi:"protocolTemplate"`
	// ID of the security group to be queried.
	SecurityGroupId pulumi.StringOutput `pulumi:"securityGroupId"`
	// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
	SourceSgid pulumi.StringOutput `pulumi:"sourceSgid"`
	// Type of the security group rule. Valid values: `ingress` and `egress`.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewGroupRule registers a new resource with the given unique name, arguments, and options.
func NewGroupRule(ctx *pulumi.Context,
	name string, args *GroupRuleArgs, opts ...pulumi.ResourceOption) (*GroupRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Policy == nil {
		return nil, errors.New("invalid value for required argument 'Policy'")
	}
	if args.SecurityGroupId == nil {
		return nil, errors.New("invalid value for required argument 'SecurityGroupId'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	var resource GroupRule
	err := ctx.RegisterResource("tencentcloud:Security/groupRule:GroupRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetGroupRule gets an existing GroupRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetGroupRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *GroupRuleState, opts ...pulumi.ResourceOption) (*GroupRule, error) {
	var resource GroupRule
	err := ctx.ReadResource("tencentcloud:Security/groupRule:GroupRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering GroupRule resources.
type groupRuleState struct {
	// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
	AddressTemplate *GroupRuleAddressTemplate `pulumi:"addressTemplate"`
	// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
	CidrIp *string `pulumi:"cidrIp"`
	// Description of the security group rule.
	Description *string `pulumi:"description"`
	// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
	IpProtocol *string `pulumi:"ipProtocol"`
	// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
	Policy *string `pulumi:"policy"`
	// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
	PortRange *string `pulumi:"portRange"`
	// ID of the address template, and conflict with `ipProtocol`, `portRange`.
	ProtocolTemplate *GroupRuleProtocolTemplate `pulumi:"protocolTemplate"`
	// ID of the security group to be queried.
	SecurityGroupId *string `pulumi:"securityGroupId"`
	// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
	SourceSgid *string `pulumi:"sourceSgid"`
	// Type of the security group rule. Valid values: `ingress` and `egress`.
	Type *string `pulumi:"type"`
}

type GroupRuleState struct {
	// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
	AddressTemplate GroupRuleAddressTemplatePtrInput
	// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
	CidrIp pulumi.StringPtrInput
	// Description of the security group rule.
	Description pulumi.StringPtrInput
	// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
	IpProtocol pulumi.StringPtrInput
	// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
	Policy pulumi.StringPtrInput
	// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
	PortRange pulumi.StringPtrInput
	// ID of the address template, and conflict with `ipProtocol`, `portRange`.
	ProtocolTemplate GroupRuleProtocolTemplatePtrInput
	// ID of the security group to be queried.
	SecurityGroupId pulumi.StringPtrInput
	// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
	SourceSgid pulumi.StringPtrInput
	// Type of the security group rule. Valid values: `ingress` and `egress`.
	Type pulumi.StringPtrInput
}

func (GroupRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*groupRuleState)(nil)).Elem()
}

type groupRuleArgs struct {
	// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
	AddressTemplate *GroupRuleAddressTemplate `pulumi:"addressTemplate"`
	// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
	CidrIp *string `pulumi:"cidrIp"`
	// Description of the security group rule.
	Description *string `pulumi:"description"`
	// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
	IpProtocol *string `pulumi:"ipProtocol"`
	// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
	Policy string `pulumi:"policy"`
	// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
	PortRange *string `pulumi:"portRange"`
	// ID of the address template, and conflict with `ipProtocol`, `portRange`.
	ProtocolTemplate *GroupRuleProtocolTemplate `pulumi:"protocolTemplate"`
	// ID of the security group to be queried.
	SecurityGroupId string `pulumi:"securityGroupId"`
	// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
	SourceSgid *string `pulumi:"sourceSgid"`
	// Type of the security group rule. Valid values: `ingress` and `egress`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a GroupRule resource.
type GroupRuleArgs struct {
	// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
	AddressTemplate GroupRuleAddressTemplatePtrInput
	// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
	CidrIp pulumi.StringPtrInput
	// Description of the security group rule.
	Description pulumi.StringPtrInput
	// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
	IpProtocol pulumi.StringPtrInput
	// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
	Policy pulumi.StringInput
	// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
	PortRange pulumi.StringPtrInput
	// ID of the address template, and conflict with `ipProtocol`, `portRange`.
	ProtocolTemplate GroupRuleProtocolTemplatePtrInput
	// ID of the security group to be queried.
	SecurityGroupId pulumi.StringInput
	// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
	SourceSgid pulumi.StringPtrInput
	// Type of the security group rule. Valid values: `ingress` and `egress`.
	Type pulumi.StringInput
}

func (GroupRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*groupRuleArgs)(nil)).Elem()
}

type GroupRuleInput interface {
	pulumi.Input

	ToGroupRuleOutput() GroupRuleOutput
	ToGroupRuleOutputWithContext(ctx context.Context) GroupRuleOutput
}

func (*GroupRule) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupRule)(nil)).Elem()
}

func (i *GroupRule) ToGroupRuleOutput() GroupRuleOutput {
	return i.ToGroupRuleOutputWithContext(context.Background())
}

func (i *GroupRule) ToGroupRuleOutputWithContext(ctx context.Context) GroupRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupRuleOutput)
}

// GroupRuleArrayInput is an input type that accepts GroupRuleArray and GroupRuleArrayOutput values.
// You can construct a concrete instance of `GroupRuleArrayInput` via:
//
//          GroupRuleArray{ GroupRuleArgs{...} }
type GroupRuleArrayInput interface {
	pulumi.Input

	ToGroupRuleArrayOutput() GroupRuleArrayOutput
	ToGroupRuleArrayOutputWithContext(context.Context) GroupRuleArrayOutput
}

type GroupRuleArray []GroupRuleInput

func (GroupRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupRule)(nil)).Elem()
}

func (i GroupRuleArray) ToGroupRuleArrayOutput() GroupRuleArrayOutput {
	return i.ToGroupRuleArrayOutputWithContext(context.Background())
}

func (i GroupRuleArray) ToGroupRuleArrayOutputWithContext(ctx context.Context) GroupRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupRuleArrayOutput)
}

// GroupRuleMapInput is an input type that accepts GroupRuleMap and GroupRuleMapOutput values.
// You can construct a concrete instance of `GroupRuleMapInput` via:
//
//          GroupRuleMap{ "key": GroupRuleArgs{...} }
type GroupRuleMapInput interface {
	pulumi.Input

	ToGroupRuleMapOutput() GroupRuleMapOutput
	ToGroupRuleMapOutputWithContext(context.Context) GroupRuleMapOutput
}

type GroupRuleMap map[string]GroupRuleInput

func (GroupRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupRule)(nil)).Elem()
}

func (i GroupRuleMap) ToGroupRuleMapOutput() GroupRuleMapOutput {
	return i.ToGroupRuleMapOutputWithContext(context.Background())
}

func (i GroupRuleMap) ToGroupRuleMapOutputWithContext(ctx context.Context) GroupRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupRuleMapOutput)
}

type GroupRuleOutput struct{ *pulumi.OutputState }

func (GroupRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupRule)(nil)).Elem()
}

func (o GroupRuleOutput) ToGroupRuleOutput() GroupRuleOutput {
	return o
}

func (o GroupRuleOutput) ToGroupRuleOutputWithContext(ctx context.Context) GroupRuleOutput {
	return o
}

// ID of the address template, and confilicts with `sourceSgid` and `cidrIp`.
func (o GroupRuleOutput) AddressTemplate() GroupRuleAddressTemplateOutput {
	return o.ApplyT(func(v *GroupRule) GroupRuleAddressTemplateOutput { return v.AddressTemplate }).(GroupRuleAddressTemplateOutput)
}

// An IP address network or segment, and conflict with `sourceSgid` and `addressTemplate`.
func (o GroupRuleOutput) CidrIp() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringPtrOutput { return v.CidrIp }).(pulumi.StringPtrOutput)
}

// Description of the security group rule.
func (o GroupRuleOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// Type of IP protocol. Valid values: `TCP`, `UDP` and `ICMP`. Default to all types protocol, and conflicts with `protocolTemplate`.
func (o GroupRuleOutput) IpProtocol() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.IpProtocol }).(pulumi.StringOutput)
}

// Rule policy of security group. Valid values: `ACCEPT` and `DROP`.
func (o GroupRuleOutput) Policy() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.Policy }).(pulumi.StringOutput)
}

// Range of the port. The available value can be one, multiple or one segment. E.g. `80`, `80,90` and `80-90`. Default to all ports, and confilicts with `protocolTemplate`.
func (o GroupRuleOutput) PortRange() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.PortRange }).(pulumi.StringOutput)
}

// ID of the address template, and conflict with `ipProtocol`, `portRange`.
func (o GroupRuleOutput) ProtocolTemplate() GroupRuleProtocolTemplateOutput {
	return o.ApplyT(func(v *GroupRule) GroupRuleProtocolTemplateOutput { return v.ProtocolTemplate }).(GroupRuleProtocolTemplateOutput)
}

// ID of the security group to be queried.
func (o GroupRuleOutput) SecurityGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.SecurityGroupId }).(pulumi.StringOutput)
}

// ID of the nested security group, and conflicts with `cidrIp` and `addressTemplate`.
func (o GroupRuleOutput) SourceSgid() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.SourceSgid }).(pulumi.StringOutput)
}

// Type of the security group rule. Valid values: `ingress` and `egress`.
func (o GroupRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *GroupRule) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type GroupRuleArrayOutput struct{ *pulumi.OutputState }

func (GroupRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*GroupRule)(nil)).Elem()
}

func (o GroupRuleArrayOutput) ToGroupRuleArrayOutput() GroupRuleArrayOutput {
	return o
}

func (o GroupRuleArrayOutput) ToGroupRuleArrayOutputWithContext(ctx context.Context) GroupRuleArrayOutput {
	return o
}

func (o GroupRuleArrayOutput) Index(i pulumi.IntInput) GroupRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *GroupRule {
		return vs[0].([]*GroupRule)[vs[1].(int)]
	}).(GroupRuleOutput)
}

type GroupRuleMapOutput struct{ *pulumi.OutputState }

func (GroupRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*GroupRule)(nil)).Elem()
}

func (o GroupRuleMapOutput) ToGroupRuleMapOutput() GroupRuleMapOutput {
	return o
}

func (o GroupRuleMapOutput) ToGroupRuleMapOutputWithContext(ctx context.Context) GroupRuleMapOutput {
	return o
}

func (o GroupRuleMapOutput) MapIndex(k pulumi.StringInput) GroupRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *GroupRule {
		return vs[0].(map[string]*GroupRule)[vs[1].(string)]
	}).(GroupRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*GroupRuleInput)(nil)).Elem(), &GroupRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupRuleArrayInput)(nil)).Elem(), GroupRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupRuleMapInput)(nil)).Elem(), GroupRuleMap{})
	pulumi.RegisterOutputType(GroupRuleOutput{})
	pulumi.RegisterOutputType(GroupRuleArrayOutput{})
	pulumi.RegisterOutputType(GroupRuleMapOutput{})
}
