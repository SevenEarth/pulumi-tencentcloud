// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ProviderAssumeRole {
    policy?: pulumi.Input<string>;
    roleArn: pulumi.Input<string>;
    sessionDuration: pulumi.Input<number>;
    sessionName: pulumi.Input<string>;
}
export namespace APIGateway {
    export interface APIRequestParameter {
        defaultValue?: pulumi.Input<string>;
        desc?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        position: pulumi.Input<string>;
        required?: pulumi.Input<boolean>;
        type: pulumi.Input<string>;
    }

    export interface APIResponseErrorCode {
        code: pulumi.Input<number>;
        convertedCode?: pulumi.Input<number>;
        desc?: pulumi.Input<string>;
        msg: pulumi.Input<string>;
        needConvert?: pulumi.Input<boolean>;
    }

    export interface ServiceApiList {
        apiDesc?: pulumi.Input<string>;
        apiId?: pulumi.Input<string>;
        apiName?: pulumi.Input<string>;
        method?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface ServiceUsagePlanList {
        apiId?: pulumi.Input<string>;
        bindType?: pulumi.Input<string>;
        usagePlanId?: pulumi.Input<string>;
        usagePlanName?: pulumi.Input<string>;
    }

    export interface UsagePlanAttachList {
        apiId?: pulumi.Input<string>;
        apiName?: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        environment?: pulumi.Input<string>;
        method?: pulumi.Input<string>;
        modifyTime?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        serviceId?: pulumi.Input<string>;
        serviceName?: pulumi.Input<string>;
    }
}

export namespace Address {
}

export namespace Api {
}

export namespace As {
    export interface ScalingConfigDataDisk {
        deleteWithInstance?: pulumi.Input<boolean>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface ScalingConfigInstanceNameSettings {
        instanceName: pulumi.Input<string>;
        instanceNameStyle?: pulumi.Input<string>;
    }

    export interface ScalingGroupForwardBalancerId {
        listenerId: pulumi.Input<string>;
        loadBalancerId: pulumi.Input<string>;
        ruleId?: pulumi.Input<string>;
        targetAttributes: pulumi.Input<pulumi.Input<inputs.As.ScalingGroupForwardBalancerIdTargetAttribute>[]>;
    }

    export interface ScalingGroupForwardBalancerIdTargetAttribute {
        port: pulumi.Input<number>;
        weight: pulumi.Input<number>;
    }

}

export namespace Audit {
}

export namespace Audits {
}

export namespace Availability {
}

export namespace Cam {
}

export namespace Cbs {
}

export namespace Ccn {
}

export namespace Cdh {
    export interface InstanceHostResource {
        cpuAvailableNum?: pulumi.Input<number>;
        cpuTotalNum?: pulumi.Input<number>;
        diskAvailableSize?: pulumi.Input<number>;
        diskTotalSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        memoryAvailableSize?: pulumi.Input<number>;
        memoryTotalSize?: pulumi.Input<number>;
    }

}

export namespace Cdn {
    export interface CdnDomainAuthentication {
        switch?: pulumi.Input<string>;
        typeA?: pulumi.Input<inputs.Cdn.CdnDomainAuthenticationTypeA>;
        typeB?: pulumi.Input<inputs.Cdn.CdnDomainAuthenticationTypeB>;
        typeC?: pulumi.Input<inputs.Cdn.CdnDomainAuthenticationTypeC>;
        typeD?: pulumi.Input<inputs.Cdn.CdnDomainAuthenticationTypeD>;
    }

    export interface CdnDomainAuthenticationTypeA {
        backupSecretKey?: pulumi.Input<string>;
        expireTime: pulumi.Input<number>;
        fileExtensions: pulumi.Input<pulumi.Input<string>[]>;
        filterType: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
        signParam: pulumi.Input<string>;
    }

    export interface CdnDomainAuthenticationTypeB {
        backupSecretKey?: pulumi.Input<string>;
        expireTime: pulumi.Input<number>;
        fileExtensions: pulumi.Input<pulumi.Input<string>[]>;
        filterType: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
    }

    export interface CdnDomainAuthenticationTypeC {
        backupSecretKey?: pulumi.Input<string>;
        expireTime: pulumi.Input<number>;
        fileExtensions: pulumi.Input<pulumi.Input<string>[]>;
        filterType: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
        timeFormat?: pulumi.Input<string>;
    }

    export interface CdnDomainAuthenticationTypeD {
        backupSecretKey?: pulumi.Input<string>;
        expireTime: pulumi.Input<number>;
        fileExtensions: pulumi.Input<pulumi.Input<string>[]>;
        filterType: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
        timeFormat?: pulumi.Input<string>;
        timeParam?: pulumi.Input<string>;
    }

    export interface CdnDomainAwsPrivateAccess {
        accessKey?: pulumi.Input<string>;
        bucket?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
        secretKey?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainBandWidthAlert {
        alertPercentage?: pulumi.Input<number>;
        alertSwitch?: pulumi.Input<string>;
        bpsThreshold?: pulumi.Input<number>;
        counterMeasure?: pulumi.Input<string>;
        lastTriggerTime?: pulumi.Input<string>;
        lastTriggerTimeOverseas?: pulumi.Input<string>;
        metric?: pulumi.Input<string>;
        statisticItem?: pulumi.Input<inputs.Cdn.CdnDomainBandWidthAlertStatisticItem>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainBandWidthAlertStatisticItem {
        alertPercentage?: pulumi.Input<number>;
        alertSwitch?: pulumi.Input<string>;
        bpsThreshold?: pulumi.Input<number>;
        counterMeasure?: pulumi.Input<string>;
        cycle?: pulumi.Input<number>;
        metric?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        unblockTime?: pulumi.Input<number>;
    }

    export interface CdnDomainCompression {
        compressionRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainCompressionCompressionRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainCompressionCompressionRule {
        algorithms: pulumi.Input<pulumi.Input<string>[]>;
        compress: pulumi.Input<boolean>;
        fileExtensions?: pulumi.Input<pulumi.Input<string>[]>;
        maxLength: pulumi.Input<number>;
        minLength: pulumi.Input<number>;
        rulePaths?: pulumi.Input<pulumi.Input<string>[]>;
        ruleType?: pulumi.Input<string>;
    }

    export interface CdnDomainDownstreamCapping {
        cappingRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainDownstreamCappingCappingRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainDownstreamCappingCappingRule {
        kbpsThreshold: pulumi.Input<number>;
        rulePaths: pulumi.Input<pulumi.Input<string>[]>;
        ruleType: pulumi.Input<string>;
    }

    export interface CdnDomainErrorPage {
        pageRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainErrorPagePageRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainErrorPagePageRule {
        redirectCode: pulumi.Input<number>;
        redirectUrl: pulumi.Input<string>;
        statusCode: pulumi.Input<number>;
    }

    export interface CdnDomainHttpsConfig {
        clientCertificateConfig?: pulumi.Input<inputs.Cdn.CdnDomainHttpsConfigClientCertificateConfig>;
        forceRedirect?: pulumi.Input<inputs.Cdn.CdnDomainHttpsConfigForceRedirect>;
        http2Switch?: pulumi.Input<string>;
        httpsSwitch: pulumi.Input<string>;
        ocspStaplingSwitch?: pulumi.Input<string>;
        serverCertificateConfig?: pulumi.Input<inputs.Cdn.CdnDomainHttpsConfigServerCertificateConfig>;
        spdySwitch?: pulumi.Input<string>;
        verifyClient?: pulumi.Input<string>;
    }

    export interface CdnDomainHttpsConfigClientCertificateConfig {
        certificateContent: pulumi.Input<string>;
        certificateName?: pulumi.Input<string>;
        deployTime?: pulumi.Input<string>;
        expireTime?: pulumi.Input<string>;
    }

    export interface CdnDomainHttpsConfigForceRedirect {
        redirectStatusCode?: pulumi.Input<number>;
        redirectType?: pulumi.Input<string>;
        switch?: pulumi.Input<string>;
    }

    export interface CdnDomainHttpsConfigServerCertificateConfig {
        certificateContent?: pulumi.Input<string>;
        certificateId?: pulumi.Input<string>;
        certificateName?: pulumi.Input<string>;
        deployTime?: pulumi.Input<string>;
        expireTime?: pulumi.Input<string>;
        message?: pulumi.Input<string>;
        privateKey?: pulumi.Input<string>;
    }

    export interface CdnDomainHwPrivateAccess {
        accessKey?: pulumi.Input<string>;
        bucket?: pulumi.Input<string>;
        secretKey?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainIpFilter {
        filterRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainIpFilterFilterRule>[]>;
        filterType?: pulumi.Input<string>;
        filters?: pulumi.Input<pulumi.Input<string>[]>;
        returnCode?: pulumi.Input<number>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainIpFilterFilterRule {
        filterType: pulumi.Input<string>;
        filters: pulumi.Input<pulumi.Input<string>[]>;
        rulePaths: pulumi.Input<pulumi.Input<string>[]>;
        ruleType: pulumi.Input<string>;
    }

    export interface CdnDomainIpFreqLimit {
        qps?: pulumi.Input<number>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainMaxAge {
        maxAgeRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainMaxAgeMaxAgeRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainMaxAgeMaxAgeRule {
        followOrigin?: pulumi.Input<string>;
        maxAgeContents: pulumi.Input<pulumi.Input<string>[]>;
        maxAgeTime: pulumi.Input<number>;
        maxAgeType: pulumi.Input<string>;
    }

    export interface CdnDomainOrigin {
        backupOriginLists?: pulumi.Input<pulumi.Input<string>[]>;
        backupOriginType?: pulumi.Input<string>;
        backupServerName?: pulumi.Input<string>;
        cosPrivateAccess?: pulumi.Input<string>;
        originLists: pulumi.Input<pulumi.Input<string>[]>;
        originPullProtocol?: pulumi.Input<string>;
        originType: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface CdnDomainOriginPullOptimization {
        optimizationType?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainOriginPullTimeout {
        connectTimeout: pulumi.Input<number>;
        receiveTimeout: pulumi.Input<number>;
    }

    export interface CdnDomainOssPrivateAccess {
        accessKey?: pulumi.Input<string>;
        bucket?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
        secretKey?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainQnPrivateAccess {
        accessKey?: pulumi.Input<string>;
        secretKey?: pulumi.Input<string>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainReferer {
        refererRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainRefererRefererRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainRefererRefererRule {
        allowEmpty: pulumi.Input<boolean>;
        refererType: pulumi.Input<string>;
        referers: pulumi.Input<pulumi.Input<string>[]>;
        rulePaths: pulumi.Input<pulumi.Input<string>[]>;
        ruleType: pulumi.Input<string>;
    }

    export interface CdnDomainRequestHeader {
        headerRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainRequestHeaderHeaderRule>[]>;
        switch?: pulumi.Input<string>;
    }

    export interface CdnDomainRequestHeaderHeaderRule {
        headerMode: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        rulePaths: pulumi.Input<pulumi.Input<string>[]>;
        ruleType: pulumi.Input<string>;
    }

    export interface CdnDomainResponseHeader {
        headerRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainResponseHeaderHeaderRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainResponseHeaderHeaderRule {
        headerMode: pulumi.Input<string>;
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
        rulePaths: pulumi.Input<pulumi.Input<string>[]>;
        ruleType: pulumi.Input<string>;
    }

    export interface CdnDomainRuleCach {
        cacheTime: pulumi.Input<number>;
        compareMaxAge?: pulumi.Input<string>;
        followOriginSwitch?: pulumi.Input<string>;
        ignoreCacheControl?: pulumi.Input<string>;
        ignoreSetCookie?: pulumi.Input<string>;
        noCacheSwitch?: pulumi.Input<string>;
        reValidate?: pulumi.Input<string>;
        rulePaths?: pulumi.Input<pulumi.Input<string>[]>;
        ruleType?: pulumi.Input<string>;
        switch?: pulumi.Input<string>;
    }

    export interface CdnDomainStatusCodeCache {
        cacheRules?: pulumi.Input<pulumi.Input<inputs.Cdn.CdnDomainStatusCodeCacheCacheRule>[]>;
        switch: pulumi.Input<string>;
    }

    export interface CdnDomainStatusCodeCacheCacheRule {
        cacheTime: pulumi.Input<number>;
        statusCode: pulumi.Input<string>;
    }

}

export namespace Cfs {
}

export namespace Ckafka {
    export interface InstanceConfig {
        autoCreateTopicEnable: pulumi.Input<boolean>;
        defaultNumPartitions: pulumi.Input<number>;
        defaultReplicationFactor: pulumi.Input<number>;
    }

    export interface InstanceDynamicRetentionConfig {
        bottomRetention?: pulumi.Input<number>;
        diskQuotaPercentage?: pulumi.Input<number>;
        enable?: pulumi.Input<number>;
        stepForwardPercentage?: pulumi.Input<number>;
    }

    export interface InstanceTag {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

}

export namespace Clb {
    export interface InstanceSnatIp {
        ip?: pulumi.Input<string>;
        subnetId: pulumi.Input<string>;
    }

    export interface ServerAttachmentTarget {
        eniIp?: pulumi.Input<string>;
        instanceId?: pulumi.Input<string>;
        port: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface TargetGroupTargetGroupInstance {
        bindIp: pulumi.Input<string>;
        newPort?: pulumi.Input<number>;
        port: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

}

export namespace Cloud {
}

export namespace Cls {
    export interface ConfigExcludePath {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ConfigExtraContainerFile {
        container: pulumi.Input<string>;
        excludeLabels?: pulumi.Input<pulumi.Input<string>[]>;
        excludeNamespace?: pulumi.Input<string>;
        filePattern: pulumi.Input<string>;
        includeLabels?: pulumi.Input<pulumi.Input<string>[]>;
        logPath: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
        workload?: pulumi.Input<inputs.Cls.ConfigExtraContainerFileWorkload>;
    }

    export interface ConfigExtraContainerFileWorkload {
        container?: pulumi.Input<string>;
        kind: pulumi.Input<string>;
        name: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
    }

    export interface ConfigExtraContainerStdout {
        allContainers: pulumi.Input<boolean>;
        excludeLabels?: pulumi.Input<pulumi.Input<string>[]>;
        excludeNamespace?: pulumi.Input<string>;
        includeLabels?: pulumi.Input<pulumi.Input<string>[]>;
        namespace?: pulumi.Input<string>;
        workloads?: pulumi.Input<pulumi.Input<inputs.Cls.ConfigExtraContainerStdoutWorkload>[]>;
    }

    export interface ConfigExtraContainerStdoutWorkload {
        container?: pulumi.Input<string>;
        kind: pulumi.Input<string>;
        name: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
    }

    export interface ConfigExtraExcludePath {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ConfigExtraExtractRule {
        backtracking?: pulumi.Input<number>;
        beginRegex?: pulumi.Input<string>;
        delimiter?: pulumi.Input<string>;
        filterKeyRegexes?: pulumi.Input<pulumi.Input<inputs.Cls.ConfigExtraExtractRuleFilterKeyRegex>[]>;
        keys?: pulumi.Input<pulumi.Input<string>[]>;
        logRegex?: pulumi.Input<string>;
        timeFormat?: pulumi.Input<string>;
        timeKey?: pulumi.Input<string>;
        unMatchLogKey?: pulumi.Input<string>;
        unMatchUpLoadSwitch?: pulumi.Input<boolean>;
    }

    export interface ConfigExtraExtractRuleFilterKeyRegex {
        key?: pulumi.Input<string>;
        regex?: pulumi.Input<string>;
    }

    export interface ConfigExtraHostFile {
        customLabels?: pulumi.Input<pulumi.Input<string>[]>;
        filePattern: pulumi.Input<string>;
        logPath: pulumi.Input<string>;
    }

    export interface ConfigExtractRule {
        backtracking?: pulumi.Input<number>;
        beginRegex?: pulumi.Input<string>;
        delimiter?: pulumi.Input<string>;
        filterKeyRegexes?: pulumi.Input<pulumi.Input<inputs.Cls.ConfigExtractRuleFilterKeyRegex>[]>;
        keys?: pulumi.Input<pulumi.Input<string>[]>;
        logRegex?: pulumi.Input<string>;
        timeFormat?: pulumi.Input<string>;
        timeKey?: pulumi.Input<string>;
        unMatchLogKey?: pulumi.Input<string>;
        unMatchUpLoadSwitch?: pulumi.Input<boolean>;
    }

    export interface ConfigExtractRuleFilterKeyRegex {
        key?: pulumi.Input<string>;
        regex?: pulumi.Input<string>;
    }

    export interface CosShipperCompress {
        format: pulumi.Input<string>;
    }

    export interface CosShipperContent {
        csv?: pulumi.Input<inputs.Cls.CosShipperContentCsv>;
        format: pulumi.Input<string>;
        json?: pulumi.Input<inputs.Cls.CosShipperContentJson>;
    }

    export interface CosShipperContentCsv {
        delimiter: pulumi.Input<string>;
        escapeChar: pulumi.Input<string>;
        keys: pulumi.Input<pulumi.Input<string>[]>;
        nonExistingField: pulumi.Input<string>;
        printKey: pulumi.Input<boolean>;
    }

    export interface CosShipperContentJson {
        enableTag: pulumi.Input<boolean>;
        metaFields: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CosShipperFilterRule {
        key: pulumi.Input<string>;
        regex: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface MachineGroupMachineGroupType {
        type: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace Container {
}

export namespace Cos {
    export interface CosBucketCorsRule {
        allowedHeaders: pulumi.Input<pulumi.Input<string>[]>;
        allowedMethods: pulumi.Input<pulumi.Input<string>[]>;
        allowedOrigins: pulumi.Input<pulumi.Input<string>[]>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAgeSeconds?: pulumi.Input<number>;
    }

    export interface CosBucketLifecycleRule {
        expiration?: pulumi.Input<inputs.Cos.CosBucketLifecycleRuleExpiration>;
        filterPrefix: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        nonCurrentExpiration?: pulumi.Input<inputs.Cos.CosBucketLifecycleRuleNonCurrentExpiration>;
        nonCurrentTransitions?: pulumi.Input<pulumi.Input<inputs.Cos.CosBucketLifecycleRuleNonCurrentTransition>[]>;
        transitions?: pulumi.Input<pulumi.Input<inputs.Cos.CosBucketLifecycleRuleTransition>[]>;
    }

    export interface CosBucketLifecycleRuleExpiration {
        date?: pulumi.Input<string>;
        days?: pulumi.Input<number>;
        deleteMarker?: pulumi.Input<boolean>;
    }

    export interface CosBucketLifecycleRuleNonCurrentExpiration {
        nonCurrentDays?: pulumi.Input<number>;
    }

    export interface CosBucketLifecycleRuleNonCurrentTransition {
        nonCurrentDays?: pulumi.Input<number>;
        storageClass: pulumi.Input<string>;
    }

    export interface CosBucketLifecycleRuleTransition {
        date?: pulumi.Input<string>;
        days?: pulumi.Input<number>;
        storageClass: pulumi.Input<string>;
    }

    export interface CosBucketOriginDomainRule {
        domain: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface CosBucketOriginPullRule {
        customHttpHeaders?: pulumi.Input<{[key: string]: any}>;
        followHttpHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        followQueryString?: pulumi.Input<boolean>;
        followRedirection?: pulumi.Input<boolean>;
        host: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        priority: pulumi.Input<number>;
        protocol?: pulumi.Input<string>;
        syncBackToSource?: pulumi.Input<boolean>;
    }

    export interface CosBucketReplicaRule {
        destinationBucket: pulumi.Input<string>;
        destinationStorageClass?: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        status: pulumi.Input<string>;
    }

    export interface CosBucketWebsite {
        errorDocument?: pulumi.Input<string>;
        indexDocument?: pulumi.Input<string>;
    }
}

export namespace Cvm {
    export interface InstanceDataDisk {
        dataDiskId?: pulumi.Input<string>;
        dataDiskSize: pulumi.Input<number>;
        dataDiskSnapshotId?: pulumi.Input<string>;
        dataDiskType: pulumi.Input<string>;
        deleteWithInstance?: pulumi.Input<boolean>;
        encrypt?: pulumi.Input<boolean>;
        throughputPerformance?: pulumi.Input<number>;
    }

    export interface InstancesTypesFilter {
        name: string;
        values: string[];
    }

    export interface InstancesTypesFilterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

}

export namespace Cynosdb {
    export interface ClusterParamItem {
        currentValue: pulumi.Input<string>;
        name: pulumi.Input<string>;
        oldValue?: pulumi.Input<string>;
    }

    export interface ClusterRoGroupAddr {
        ip?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface ClusterRoGroupInstance {
        instanceId?: pulumi.Input<string>;
        instanceName?: pulumi.Input<string>;
    }

    export interface ClusterRwGroupAddr {
        ip?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface ClusterRwGroupInstance {
        instanceId?: pulumi.Input<string>;
        instanceName?: pulumi.Input<string>;
    }

}

export namespace Dayu {
    export interface CCHttpPolicyRuleList {
        operator?: pulumi.Input<string>;
        skey?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface CCHttpsPolicyRuleList {
        operator: pulumi.Input<string>;
        skey: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcBlackWhiteIp {
        blackWhiteIp: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        domain: pulumi.Input<string>;
        modifyTime?: pulumi.Input<string>;
        protocol: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcGeoIpPolicy {
        action: pulumi.Input<string>;
        areaLists?: pulumi.Input<pulumi.Input<number>[]>;
        createTime?: pulumi.Input<string>;
        domain: pulumi.Input<string>;
        modifyTime?: pulumi.Input<string>;
        protocol: pulumi.Input<string>;
        regionType: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcPrecisionPolicy {
        domain: pulumi.Input<string>;
        ip: pulumi.Input<string>;
        policyAction: pulumi.Input<string>;
        policyId?: pulumi.Input<string>;
        policys: pulumi.Input<pulumi.Input<inputs.Dayu.CCPolicyV2CcPrecisionPolicyPolicy>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcPrecisionPolicyPolicy {
        fieldName: pulumi.Input<string>;
        fieldType: pulumi.Input<string>;
        value: pulumi.Input<string>;
        valueOperator: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcPrecisionReqLimit {
        domain: pulumi.Input<string>;
        instanceId?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        level: pulumi.Input<string>;
        policys: pulumi.Input<pulumi.Input<inputs.Dayu.CCPolicyV2CcPrecisionReqLimitPolicy>[]>;
        protocol: pulumi.Input<string>;
    }

    export interface CCPolicyV2CcPrecisionReqLimitPolicy {
        action: pulumi.Input<string>;
        cookie?: pulumi.Input<string>;
        executeDuration: pulumi.Input<number>;
        mode: pulumi.Input<string>;
        period: pulumi.Input<number>;
        requestNum: pulumi.Input<number>;
        uri?: pulumi.Input<string>;
        userAgent?: pulumi.Input<string>;
    }

    export interface CCPolicyV2Threshold {
        domain: pulumi.Input<string>;
        threshold: pulumi.Input<number>;
    }

    export interface DdosPolicyDropOption {
        badConnThreshold: pulumi.Input<number>;
        checkSyncConn: pulumi.Input<boolean>;
        connTimeout: pulumi.Input<number>;
        dConnLimit: pulumi.Input<number>;
        dNewLimit: pulumi.Input<number>;
        dropAbroad: pulumi.Input<boolean>;
        dropIcmp: pulumi.Input<boolean>;
        dropOther: pulumi.Input<boolean>;
        dropTcp: pulumi.Input<boolean>;
        dropUdp: pulumi.Input<boolean>;
        icmpMbpsLimit: pulumi.Input<number>;
        nullConnEnable: pulumi.Input<boolean>;
        otherMbpsLimit: pulumi.Input<number>;
        sConnLimit: pulumi.Input<number>;
        sNewLimit: pulumi.Input<number>;
        synLimit: pulumi.Input<number>;
        synRate?: pulumi.Input<number>;
        tcpMbpsLimit: pulumi.Input<number>;
        udpMbpsLimit: pulumi.Input<number>;
    }

    export interface DdosPolicyPacketFilter {
        action?: pulumi.Input<string>;
        dEndPort?: pulumi.Input<number>;
        dStartPort?: pulumi.Input<number>;
        depth?: pulumi.Input<number>;
        isInclude?: pulumi.Input<boolean>;
        matchBegin?: pulumi.Input<string>;
        matchStr?: pulumi.Input<string>;
        matchType?: pulumi.Input<string>;
        offset?: pulumi.Input<number>;
        pktLengthMax?: pulumi.Input<number>;
        pktLengthMin?: pulumi.Input<number>;
        protocol?: pulumi.Input<string>;
        sEndPort?: pulumi.Input<number>;
        sStartPort?: pulumi.Input<number>;
    }

    export interface DdosPolicyPortFilter {
        action?: pulumi.Input<string>;
        endPort?: pulumi.Input<number>;
        kind?: pulumi.Input<number>;
        protocol?: pulumi.Input<string>;
        startPort?: pulumi.Input<number>;
    }

    export interface DdosPolicyV2Acl {
        action: pulumi.Input<string>;
        dPortEnd: pulumi.Input<number>;
        dPortStart: pulumi.Input<number>;
        forwardProtocol: pulumi.Input<string>;
        priority: pulumi.Input<number>;
        sPortEnd: pulumi.Input<number>;
        sPortStart: pulumi.Input<number>;
    }

    export interface DdosPolicyV2BlackWhiteIp {
        ip: pulumi.Input<string>;
        ipType: pulumi.Input<string>;
    }

    export interface DdosPolicyV2DdosConnectLimit {
        badConnThreshold: pulumi.Input<number>;
        connTimeout: pulumi.Input<number>;
        dstConnLimit: pulumi.Input<number>;
        dstNewLimit: pulumi.Input<number>;
        nullConnEnable: pulumi.Input<number>;
        sdConnLimit: pulumi.Input<number>;
        sdNewLimit: pulumi.Input<number>;
        synLimit: pulumi.Input<number>;
        synRate: pulumi.Input<number>;
    }

    export interface DdosPolicyV2DdosGeoIpBlockConfig {
        action: pulumi.Input<string>;
        areaLists: pulumi.Input<pulumi.Input<number>[]>;
        regionType: pulumi.Input<string>;
    }

    export interface DdosPolicyV2DdosSpeedLimitConfig {
        bandwidth: pulumi.Input<number>;
        dstPortList: pulumi.Input<string>;
        mode: pulumi.Input<number>;
        packetRate: pulumi.Input<number>;
        protocolList: pulumi.Input<string>;
    }

    export interface DdosPolicyV2PacketFilter {
        action: pulumi.Input<string>;
        dPortEnd: pulumi.Input<number>;
        dPortStart: pulumi.Input<number>;
        depth: pulumi.Input<number>;
        depth2: pulumi.Input<number>;
        isNot: pulumi.Input<number>;
        isNot2: pulumi.Input<number>;
        matchBegin: pulumi.Input<string>;
        matchBegin2: pulumi.Input<string>;
        matchLogic: pulumi.Input<string>;
        matchType: pulumi.Input<string>;
        matchType2: pulumi.Input<string>;
        offset: pulumi.Input<number>;
        offset2: pulumi.Input<number>;
        pktlenMax: pulumi.Input<number>;
        pktlenMin: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        sPortEnd: pulumi.Input<number>;
        sPortStart: pulumi.Input<number>;
        str: pulumi.Input<string>;
        str2: pulumi.Input<string>;
    }

    export interface DdosPolicyV2ProtocolBlockConfig {
        dropIcmp: pulumi.Input<number>;
        dropOther: pulumi.Input<number>;
        dropTcp: pulumi.Input<number>;
        dropUdp: pulumi.Input<number>;
    }

    export interface DdosPolicyWatermarkFilter {
        autoRemove?: pulumi.Input<boolean>;
        offset?: pulumi.Input<number>;
        openSwitch?: pulumi.Input<boolean>;
        tcpPortLists?: pulumi.Input<pulumi.Input<string>[]>;
        udpPortLists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DdosPolicyWatermarkKey {
        content?: pulumi.Input<string>;
        createTime?: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        openSwitch?: pulumi.Input<boolean>;
    }

    export interface L4RuleSourceList {
        source: pulumi.Input<string>;
        weight: pulumi.Input<number>;
    }

    export interface L4RuleV2Rules {
        keepEnable: pulumi.Input<boolean>;
        keeptime: pulumi.Input<number>;
        lbType: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        region: pulumi.Input<number>;
        removeSwitch: pulumi.Input<boolean>;
        ruleName: pulumi.Input<string>;
        sourceLists: pulumi.Input<pulumi.Input<inputs.Dayu.L4RuleV2RulesSourceList>[]>;
        sourcePort: pulumi.Input<number>;
        sourceType: pulumi.Input<number>;
        virtualPort: pulumi.Input<number>;
    }

    export interface L4RuleV2RulesSourceList {
        source: pulumi.Input<string>;
        weight: pulumi.Input<number>;
    }

    export interface L7RuleV2Rule {
        ccEnable?: pulumi.Input<number>;
        certType?: pulumi.Input<number>;
        domain: pulumi.Input<string>;
        httpsToHttpEnable?: pulumi.Input<number>;
        keepEnable: pulumi.Input<number>;
        keeptime: pulumi.Input<number>;
        lbType: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        sourceLists: pulumi.Input<pulumi.Input<inputs.Dayu.L7RuleV2RuleSourceList>[]>;
        sourceType: pulumi.Input<number>;
        sslId?: pulumi.Input<string>;
    }

    export interface L7RuleV2RuleSourceList {
        source: pulumi.Input<string>;
        weight: pulumi.Input<number>;
    }

}

export namespace Dc {
}

export namespace Dcx {
}

export namespace Dnats {
}

export namespace Eip {
    export interface InstancesFilter {
        name: string;
        values: string[];
    }

    export interface InstancesFilterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace Eips {
}

export namespace Eks {
    export interface ClusterDnsServer {
        domain?: pulumi.Input<string>;
        servers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterInternalLb {
        enabled: pulumi.Input<boolean>;
        subnetId?: pulumi.Input<string>;
    }

    export interface ClusterPublicLb {
        allowFromCidrs?: pulumi.Input<pulumi.Input<string>[]>;
        enabled: pulumi.Input<boolean>;
        extraParam?: pulumi.Input<string>;
        securityGroup?: pulumi.Input<string>;
        securityPolicies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ContainerInstanceCbsVolume {
        diskId: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface ContainerInstanceContainer {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        cpu?: pulumi.Input<number>;
        envVars?: pulumi.Input<{[key: string]: any}>;
        image: pulumi.Input<string>;
        livenessProbe?: pulumi.Input<inputs.Eks.ContainerInstanceContainerLivenessProbe>;
        memory?: pulumi.Input<number>;
        name: pulumi.Input<string>;
        readinessProbe?: pulumi.Input<inputs.Eks.ContainerInstanceContainerReadinessProbe>;
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.Eks.ContainerInstanceContainerVolumeMount>[]>;
        workingDir?: pulumi.Input<string>;
    }

    export interface ContainerInstanceContainerLivenessProbe {
        execCommands?: pulumi.Input<pulumi.Input<string>[]>;
        failureThreshold?: pulumi.Input<number>;
        httpGetPath?: pulumi.Input<string>;
        httpGetPort?: pulumi.Input<number>;
        httpGetScheme?: pulumi.Input<string>;
        initDelaySeconds?: pulumi.Input<number>;
        periodSeconds?: pulumi.Input<number>;
        successThreshold?: pulumi.Input<number>;
        tcpSocketPort?: pulumi.Input<number>;
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ContainerInstanceContainerReadinessProbe {
        execCommands?: pulumi.Input<pulumi.Input<string>[]>;
        failureThreshold?: pulumi.Input<number>;
        httpGetPath?: pulumi.Input<string>;
        httpGetPort?: pulumi.Input<number>;
        httpGetScheme?: pulumi.Input<string>;
        initDelaySeconds?: pulumi.Input<number>;
        periodSeconds?: pulumi.Input<number>;
        successThreshold?: pulumi.Input<number>;
        tcpSocketPort?: pulumi.Input<number>;
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface ContainerInstanceContainerVolumeMount {
        mountPropagation?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        path: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        subPath?: pulumi.Input<string>;
        subPathExpr?: pulumi.Input<string>;
    }

    export interface ContainerInstanceImageRegistryCredential {
        name?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        server?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface ContainerInstanceInitContainer {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        commands?: pulumi.Input<pulumi.Input<string>[]>;
        cpu?: pulumi.Input<number>;
        envVars?: pulumi.Input<{[key: string]: any}>;
        image: pulumi.Input<string>;
        memory?: pulumi.Input<number>;
        name: pulumi.Input<string>;
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.Eks.ContainerInstanceInitContainerVolumeMount>[]>;
        workingDir?: pulumi.Input<string>;
    }

    export interface ContainerInstanceInitContainerVolumeMount {
        mountPropagation?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        path: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        subPath?: pulumi.Input<string>;
        subPathExpr?: pulumi.Input<string>;
    }

    export interface ContainerInstanceNfsVolume {
        name: pulumi.Input<string>;
        path: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        server: pulumi.Input<string>;
    }
}

export namespace Elasticsearch {
    export interface InstanceMultiZoneInfo {
        availabilityZone: pulumi.Input<string>;
        subnetId: pulumi.Input<string>;
    }

    export interface InstanceNodeInfoList {
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        encrypt?: pulumi.Input<boolean>;
        nodeNum: pulumi.Input<number>;
        nodeType: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface InstanceWebNodeTypeInfo {
        nodeNum: pulumi.Input<number>;
        nodeType: pulumi.Input<string>;
    }

}

export namespace Emr {
    export interface ClusterResourceSpec {
        commonCount?: pulumi.Input<number>;
        commonResourceSpec?: pulumi.Input<inputs.Emr.ClusterResourceSpecCommonResourceSpec>;
        coreCount?: pulumi.Input<number>;
        coreResourceSpec?: pulumi.Input<inputs.Emr.ClusterResourceSpecCoreResourceSpec>;
        masterCount?: pulumi.Input<number>;
        masterResourceSpec?: pulumi.Input<inputs.Emr.ClusterResourceSpecMasterResourceSpec>;
        taskCount?: pulumi.Input<number>;
        taskResourceSpec?: pulumi.Input<inputs.Emr.ClusterResourceSpecTaskResourceSpec>;
    }

    export interface ClusterResourceSpecCommonResourceSpec {
        cpu?: pulumi.Input<number>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        memSize?: pulumi.Input<number>;
        rootSize?: pulumi.Input<number>;
        spec?: pulumi.Input<string>;
        storageType?: pulumi.Input<number>;
    }

    export interface ClusterResourceSpecCoreResourceSpec {
        cpu?: pulumi.Input<number>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        memSize?: pulumi.Input<number>;
        rootSize?: pulumi.Input<number>;
        spec?: pulumi.Input<string>;
        storageType?: pulumi.Input<number>;
    }

    export interface ClusterResourceSpecMasterResourceSpec {
        cpu?: pulumi.Input<number>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        memSize?: pulumi.Input<number>;
        rootSize?: pulumi.Input<number>;
        spec?: pulumi.Input<string>;
        storageType?: pulumi.Input<number>;
    }

    export interface ClusterResourceSpecTaskResourceSpec {
        cpu?: pulumi.Input<number>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        memSize?: pulumi.Input<number>;
        rootSize?: pulumi.Input<number>;
        spec?: pulumi.Input<string>;
        storageType?: pulumi.Input<number>;
    }

}

export namespace Eni {
    export interface InstanceIpv4 {
        description?: pulumi.Input<string>;
        ip: pulumi.Input<string>;
        primary: pulumi.Input<boolean>;
    }

    export interface InstanceIpv4Info {
        description?: pulumi.Input<string>;
        ip?: pulumi.Input<string>;
        primary?: pulumi.Input<boolean>;
    }
}

export namespace Enis {
}

export namespace Gaap {
    export interface HttpRuleRealserver {
        id: pulumi.Input<string>;
        ip: pulumi.Input<string>;
        port: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface Layer4ListenerRealserverBindSet {
        id: pulumi.Input<string>;
        ip: pulumi.Input<string>;
        port: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

}

export namespace Ha {
}

export namespace Instances {
}

export namespace Key {
}

export namespace Kms {
}

export namespace Mongodb {
    export interface InstanceStandbyInstanceList {
        standbyInstanceId?: pulumi.Input<string>;
        standbyInstanceRegion?: pulumi.Input<string>;
    }

}

export namespace Monitor {
    export interface AlarmPolicyConditions {
        isUnionRule?: pulumi.Input<number>;
        rules?: pulumi.Input<pulumi.Input<inputs.Monitor.AlarmPolicyConditionsRule>[]>;
    }

    export interface AlarmPolicyConditionsRule {
        continuePeriod?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        filter?: pulumi.Input<inputs.Monitor.AlarmPolicyConditionsRuleFilter>;
        isPowerNotice?: pulumi.Input<number>;
        metricName?: pulumi.Input<string>;
        noticeFrequency?: pulumi.Input<number>;
        operator?: pulumi.Input<string>;
        period?: pulumi.Input<number>;
        ruleType?: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface AlarmPolicyConditionsRuleFilter {
        dimensions?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface AlarmPolicyEventCondition {
        continuePeriod?: pulumi.Input<number>;
        description?: pulumi.Input<string>;
        filter?: pulumi.Input<inputs.Monitor.AlarmPolicyEventConditionFilter>;
        isPowerNotice?: pulumi.Input<number>;
        metricName?: pulumi.Input<string>;
        noticeFrequency?: pulumi.Input<number>;
        operator?: pulumi.Input<string>;
        period?: pulumi.Input<number>;
        ruleType?: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface AlarmPolicyEventConditionFilter {
        dimensions?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface AlarmPolicyPolicyTag {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface AlarmPolicyTriggerTask {
        taskConfig: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface BindingAlarmReceiverReceivers {
        endTime?: pulumi.Input<number>;
        notifyWays: pulumi.Input<pulumi.Input<string>[]>;
        receiveLanguage?: pulumi.Input<string>;
        receiverGroupLists?: pulumi.Input<pulumi.Input<number>[]>;
        receiverType: pulumi.Input<string>;
        receiverUserLists?: pulumi.Input<pulumi.Input<number>[]>;
        startTime?: pulumi.Input<number>;
    }

    export interface BindingObjectDimension {
        dimensionsJson: pulumi.Input<string>;
        uniqueId?: pulumi.Input<string>;
    }

    export interface DataDimension {
        name: string;
        value: string;
    }

    export interface DataDimensionArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface PolicyBindingObjectDimension {
        dimensionsJson: pulumi.Input<string>;
        uniqueId?: pulumi.Input<string>;
    }

    export interface PolicyGroupBindingObject {
        dimensionsJson?: pulumi.Input<string>;
        isShielded?: pulumi.Input<number>;
        region?: pulumi.Input<string>;
        uniqueId?: pulumi.Input<string>;
    }

    export interface PolicyGroupCondition {
        alarmNotifyPeriod: pulumi.Input<number>;
        alarmNotifyType: pulumi.Input<number>;
        calcPeriod?: pulumi.Input<number>;
        calcType?: pulumi.Input<number>;
        calcValue?: pulumi.Input<number>;
        continuePeriod?: pulumi.Input<number>;
        metricId: pulumi.Input<number>;
    }

    export interface PolicyGroupEventCondition {
        alarmNotifyPeriod: pulumi.Input<number>;
        alarmNotifyType: pulumi.Input<number>;
        eventId: pulumi.Input<number>;
    }

    export interface PolicyGroupReceiver {
        endTime?: pulumi.Input<number>;
        needSendNotice?: pulumi.Input<number>;
        notifyWays?: pulumi.Input<pulumi.Input<string>[]>;
        personInterval?: pulumi.Input<number>;
        receiveLanguage?: pulumi.Input<string>;
        receiverGroupLists?: pulumi.Input<pulumi.Input<number>[]>;
        receiverType?: pulumi.Input<string>;
        receiverUserLists?: pulumi.Input<pulumi.Input<number>[]>;
        recoverNotifies?: pulumi.Input<pulumi.Input<string>[]>;
        roundInterval?: pulumi.Input<number>;
        roundNumber?: pulumi.Input<number>;
        sendFors?: pulumi.Input<pulumi.Input<string>[]>;
        startTime?: pulumi.Input<number>;
        uidLists?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface ProductEventDimension {
        name?: string;
        value?: string;
    }

    export interface ProductEventDimensionArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

}

export namespace Mysql {
    export interface PrivilegeColumn {
        columnName: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        privileges: pulumi.Input<pulumi.Input<string>[]>;
        tableName: pulumi.Input<string>;
    }

    export interface PrivilegeDatabase {
        databaseName: pulumi.Input<string>;
        privileges: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PrivilegeTable {
        databaseName: pulumi.Input<string>;
        privileges: pulumi.Input<pulumi.Input<string>[]>;
        tableName: pulumi.Input<string>;
    }

}

export namespace Nat {
}

export namespace Nats {
}

export namespace Placement {
}

export namespace Postgresql {
    export interface InstanceBackupPlan {
        backupPeriods?: pulumi.Input<pulumi.Input<string>[]>;
        baseBackupRetentionPeriod?: pulumi.Input<number>;
        maxBackupStartTime?: pulumi.Input<string>;
        minBackupStartTime?: pulumi.Input<string>;
    }

    export interface InstanceDbNodeSet {
        role?: pulumi.Input<string>;
        zone: pulumi.Input<string>;
    }

}

export namespace PrivateDns {
    export interface ZoneAccountVpcSet {
        region: pulumi.Input<string>;
        uin: pulumi.Input<string>;
        uniqVpcId: pulumi.Input<string>;
        vpcName: pulumi.Input<string>;
    }

    export interface ZoneTagSet {
        tagKey: pulumi.Input<string>;
        tagValue: pulumi.Input<string>;
    }

    export interface ZoneVpcSet {
        region: pulumi.Input<string>;
        uniqVpcId: pulumi.Input<string>;
    }
}

export namespace Protocol {
}

export namespace Redis {
}

export namespace Reserved {
}

export namespace Route {
}

export namespace Scf {
    export interface FunctionCfsConfig {
        cfsId: pulumi.Input<string>;
        ipAddress?: pulumi.Input<string>;
        localMountDir: pulumi.Input<string>;
        mountInsId: pulumi.Input<string>;
        mountSubnetId?: pulumi.Input<string>;
        mountVpcId?: pulumi.Input<string>;
        remoteMountDir: pulumi.Input<string>;
        userGroupId: pulumi.Input<string>;
        userId: pulumi.Input<string>;
    }

    export interface FunctionImageConfig {
        args?: pulumi.Input<string>;
        command?: pulumi.Input<string>;
        entryPoint?: pulumi.Input<string>;
        imageType: pulumi.Input<string>;
        imageUri: pulumi.Input<string>;
        registryId?: pulumi.Input<string>;
    }

    export interface FunctionLayer {
        layerName: pulumi.Input<string>;
        layerVersion: pulumi.Input<number>;
    }

    export interface FunctionTrigger {
        cosRegion?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        triggerDesc: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface FunctionTriggerInfo {
        createTime?: pulumi.Input<string>;
        customArgument?: pulumi.Input<string>;
        enable?: pulumi.Input<boolean>;
        modifyTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        triggerDesc?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface LayerContent {
        cosBucketName?: pulumi.Input<string>;
        cosBucketRegion?: pulumi.Input<string>;
        cosObjectName?: pulumi.Input<string>;
        zipFile?: pulumi.Input<string>;
    }

}

export namespace Security {
    export interface GroupRuleAddressTemplate {
        groupId?: pulumi.Input<string>;
        templateId?: pulumi.Input<string>;
    }

    export interface GroupRuleProtocolTemplate {
        groupId?: pulumi.Input<string>;
        templateId?: pulumi.Input<string>;
    }

}

export namespace Sqlserver {
    export interface PublishSubscribeDatabaseTuple {
        publishDatabase: pulumi.Input<string>;
    }

}

export namespace Ssl {
    export interface InstanceInformation {
        adminEmail: pulumi.Input<string>;
        adminFirstName: pulumi.Input<string>;
        adminLastName: pulumi.Input<string>;
        adminPhoneNum: pulumi.Input<string>;
        adminPosition: pulumi.Input<string>;
        certificateDomain: pulumi.Input<string>;
        contactEmail: pulumi.Input<string>;
        contactFirstName: pulumi.Input<string>;
        contactLastName: pulumi.Input<string>;
        contactNumber: pulumi.Input<string>;
        contactPosition: pulumi.Input<string>;
        csrContent?: pulumi.Input<string>;
        csrType?: pulumi.Input<string>;
        domainLists?: pulumi.Input<pulumi.Input<string>[]>;
        keyPassword?: pulumi.Input<string>;
        organizationAddress: pulumi.Input<string>;
        organizationCity: pulumi.Input<string>;
        organizationCountry: pulumi.Input<string>;
        organizationDivision: pulumi.Input<string>;
        organizationName: pulumi.Input<string>;
        organizationRegion: pulumi.Input<string>;
        phoneAreaCode: pulumi.Input<string>;
        phoneNumber: pulumi.Input<string>;
        postalCode: pulumi.Input<string>;
        verifyType: pulumi.Input<string>;
    }
}

export namespace Ssm {
}

export namespace Tcaplus {
    export interface IdlTableInfo {
        error?: pulumi.Input<string>;
        indexKeySet?: pulumi.Input<string>;
        keyFields?: pulumi.Input<string>;
        sumKeyFieldSize?: pulumi.Input<number>;
        sumValueFieldSize?: pulumi.Input<number>;
        tableName?: pulumi.Input<string>;
        valueFields?: pulumi.Input<string>;
    }

}

export namespace Tcr {
    export interface InstanceSecurityPolicy {
        cidrBlock?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        index?: pulumi.Input<number>;
        version?: pulumi.Input<string>;
    }
}

export namespace Tke {
    export interface AsScalingGroupAutoScalingConfig {
        configurationName: pulumi.Input<string>;
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.AsScalingGroupAutoScalingConfigDataDisk>[]>;
        enhancedMonitorService?: pulumi.Input<boolean>;
        enhancedSecurityService?: pulumi.Input<boolean>;
        instanceTags?: pulumi.Input<{[key: string]: any}>;
        instanceType: pulumi.Input<string>;
        internetChargeType?: pulumi.Input<string>;
        internetMaxBandwidthOut?: pulumi.Input<number>;
        keyIds?: pulumi.Input<pulumi.Input<string>[]>;
        password?: pulumi.Input<string>;
        projectId?: pulumi.Input<number>;
        publicIpAssigned?: pulumi.Input<boolean>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        systemDiskSize?: pulumi.Input<number>;
        systemDiskType?: pulumi.Input<string>;
    }

    export interface AsScalingGroupAutoScalingConfigDataDisk {
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface AsScalingGroupAutoScalingGroup {
        defaultCooldown?: pulumi.Input<number>;
        desiredCapacity?: pulumi.Input<number>;
        forwardBalancerIds?: pulumi.Input<pulumi.Input<inputs.Tke.AsScalingGroupAutoScalingGroupForwardBalancerId>[]>;
        loadBalancerIds?: pulumi.Input<pulumi.Input<string>[]>;
        maxSize: pulumi.Input<number>;
        minSize: pulumi.Input<number>;
        projectId?: pulumi.Input<number>;
        retryPolicy?: pulumi.Input<string>;
        scalingGroupName: pulumi.Input<string>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
        tags?: pulumi.Input<{[key: string]: any}>;
        terminationPolicies?: pulumi.Input<string>;
        vpcId: pulumi.Input<string>;
        zones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerId {
        listenerId: pulumi.Input<string>;
        loadBalancerId: pulumi.Input<string>;
        ruleId?: pulumi.Input<string>;
        targetAttributes: pulumi.Input<pulumi.Input<inputs.Tke.AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute>[]>;
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute {
        port: pulumi.Input<number>;
        weight: pulumi.Input<number>;
    }

    export interface ClusterAttachmentWorkerConfig {
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.ClusterAttachmentWorkerConfigDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        dockerGraphPath?: pulumi.Input<string>;
        extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
        isSchedule?: pulumi.Input<boolean>;
        mountTarget?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface ClusterAttachmentWorkerConfigDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        fileSystem?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
    }

    export interface ClusterAttachmentWorkerConfigOverrides {
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.ClusterAttachmentWorkerConfigOverridesDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        dockerGraphPath?: pulumi.Input<string>;
        extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
        isSchedule?: pulumi.Input<boolean>;
        mountTarget?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface ClusterAttachmentWorkerConfigOverridesDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        fileSystem?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
    }

    export interface ClusterAuthOptions {
        autoCreateDiscoveryAnonymousAuth?: pulumi.Input<boolean>;
        issuer?: pulumi.Input<string>;
        jwksUri?: pulumi.Input<string>;
    }

    export interface ClusterClusterAudit {
        enabled: pulumi.Input<boolean>;
        logSetId?: pulumi.Input<string>;
        topicId?: pulumi.Input<string>;
    }

    export interface ClusterClusterExtraArgs {
        kubeApiservers?: pulumi.Input<pulumi.Input<string>[]>;
        kubeControllerManagers?: pulumi.Input<pulumi.Input<string>[]>;
        kubeSchedulers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterEventPersistence {
        enabled: pulumi.Input<boolean>;
        logSetId?: pulumi.Input<string>;
        topicId?: pulumi.Input<string>;
    }

    export interface ClusterExistInstance {
        desiredPodNumbers?: pulumi.Input<pulumi.Input<number>[]>;
        instancesPara?: pulumi.Input<inputs.Tke.ClusterExistInstanceInstancesPara>;
        nodeRole?: pulumi.Input<string>;
    }

    export interface ClusterExistInstanceInstancesPara {
        instanceIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterExtensionAddon {
        name: pulumi.Input<string>;
        param: pulumi.Input<string>;
    }

    export interface ClusterLogAgent {
        enabled: pulumi.Input<boolean>;
        kubeletRootDir?: pulumi.Input<string>;
    }

    export interface ClusterMasterConfig {
        availabilityZone?: pulumi.Input<string>;
        bandwidthPackageId?: pulumi.Input<string>;
        camRoleName?: pulumi.Input<string>;
        count?: pulumi.Input<number>;
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.ClusterMasterConfigDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        disasterRecoverGroupIds?: pulumi.Input<string>;
        enhancedMonitorService?: pulumi.Input<boolean>;
        enhancedSecurityService?: pulumi.Input<boolean>;
        hostname?: pulumi.Input<string>;
        imgId?: pulumi.Input<string>;
        instanceChargeType?: pulumi.Input<string>;
        instanceChargeTypePrepaidPeriod?: pulumi.Input<number>;
        instanceChargeTypePrepaidRenewFlag?: pulumi.Input<string>;
        instanceName?: pulumi.Input<string>;
        instanceType: pulumi.Input<string>;
        internetChargeType?: pulumi.Input<string>;
        internetMaxBandwidthOut?: pulumi.Input<number>;
        keyIds?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        publicIpAssigned?: pulumi.Input<boolean>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetId: pulumi.Input<string>;
        systemDiskSize?: pulumi.Input<number>;
        systemDiskType?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface ClusterMasterConfigDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        encrypt?: pulumi.Input<boolean>;
        fileSystem?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface ClusterNodePoolGlobalConfig {
        expander?: pulumi.Input<string>;
        ignoreDaemonSetsUtilization?: pulumi.Input<boolean>;
        isScaleInEnabled?: pulumi.Input<boolean>;
        maxConcurrentScaleIn?: pulumi.Input<number>;
        scaleInDelay?: pulumi.Input<number>;
        scaleInUnneededTime?: pulumi.Input<number>;
        scaleInUtilizationThreshold?: pulumi.Input<number>;
        skipNodesWithLocalStorage?: pulumi.Input<boolean>;
        skipNodesWithSystemPods?: pulumi.Input<boolean>;
    }

    export interface ClusterWorkerConfig {
        availabilityZone?: pulumi.Input<string>;
        bandwidthPackageId?: pulumi.Input<string>;
        camRoleName?: pulumi.Input<string>;
        count?: pulumi.Input<number>;
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.ClusterWorkerConfigDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        disasterRecoverGroupIds?: pulumi.Input<string>;
        enhancedMonitorService?: pulumi.Input<boolean>;
        enhancedSecurityService?: pulumi.Input<boolean>;
        hostname?: pulumi.Input<string>;
        imgId?: pulumi.Input<string>;
        instanceChargeType?: pulumi.Input<string>;
        instanceChargeTypePrepaidPeriod?: pulumi.Input<number>;
        instanceChargeTypePrepaidRenewFlag?: pulumi.Input<string>;
        instanceName?: pulumi.Input<string>;
        instanceType: pulumi.Input<string>;
        internetChargeType?: pulumi.Input<string>;
        internetMaxBandwidthOut?: pulumi.Input<number>;
        keyIds?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        publicIpAssigned?: pulumi.Input<boolean>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetId: pulumi.Input<string>;
        systemDiskSize?: pulumi.Input<number>;
        systemDiskType?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface ClusterWorkerConfigDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        encrypt?: pulumi.Input<boolean>;
        fileSystem?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface ClusterWorkerInstancesList {
        failedReason?: pulumi.Input<string>;
        instanceId?: pulumi.Input<string>;
        instanceRole?: pulumi.Input<string>;
        instanceState?: pulumi.Input<string>;
        lanIp?: pulumi.Input<string>;
    }

    export interface NodePoolAutoScalingConfig {
        backupInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        bandwidthPackageId?: pulumi.Input<string>;
        camRoleName?: pulumi.Input<string>;
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.NodePoolAutoScalingConfigDataDisk>[]>;
        enhancedMonitorService?: pulumi.Input<boolean>;
        enhancedSecurityService?: pulumi.Input<boolean>;
        instanceChargeType?: pulumi.Input<string>;
        instanceChargeTypePrepaidPeriod?: pulumi.Input<number>;
        instanceChargeTypePrepaidRenewFlag?: pulumi.Input<string>;
        instanceType: pulumi.Input<string>;
        internetChargeType?: pulumi.Input<string>;
        internetMaxBandwidthOut?: pulumi.Input<number>;
        keyIds?: pulumi.Input<pulumi.Input<string>[]>;
        password?: pulumi.Input<string>;
        publicIpAssigned?: pulumi.Input<boolean>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        spotInstanceType?: pulumi.Input<string>;
        spotMaxPrice?: pulumi.Input<string>;
        systemDiskSize?: pulumi.Input<number>;
        systemDiskType?: pulumi.Input<string>;
    }

    export interface NodePoolAutoScalingConfigDataDisk {
        deleteWithInstance?: pulumi.Input<boolean>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfig {
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.NodePoolNodeConfigDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        dockerGraphPath?: pulumi.Input<string>;
        extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
        isSchedule?: pulumi.Input<boolean>;
        mountTarget?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface NodePoolNodeConfigDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        fileSystem?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
    }

    export interface NodePoolTaint {
        effect: pulumi.Input<string>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ScaleWorkerDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        fileSystem?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
    }

    export interface ScaleWorkerWorkerConfig {
        availabilityZone?: pulumi.Input<string>;
        bandwidthPackageId?: pulumi.Input<string>;
        camRoleName?: pulumi.Input<string>;
        count?: pulumi.Input<number>;
        dataDisks?: pulumi.Input<pulumi.Input<inputs.Tke.ScaleWorkerWorkerConfigDataDisk>[]>;
        desiredPodNum?: pulumi.Input<number>;
        disasterRecoverGroupIds?: pulumi.Input<string>;
        enhancedMonitorService?: pulumi.Input<boolean>;
        enhancedSecurityService?: pulumi.Input<boolean>;
        hostname?: pulumi.Input<string>;
        imgId?: pulumi.Input<string>;
        instanceChargeType?: pulumi.Input<string>;
        instanceChargeTypePrepaidPeriod?: pulumi.Input<number>;
        instanceChargeTypePrepaidRenewFlag?: pulumi.Input<string>;
        instanceName?: pulumi.Input<string>;
        instanceType: pulumi.Input<string>;
        internetChargeType?: pulumi.Input<string>;
        internetMaxBandwidthOut?: pulumi.Input<number>;
        keyIds?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        publicIpAssigned?: pulumi.Input<boolean>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetId: pulumi.Input<string>;
        systemDiskSize?: pulumi.Input<number>;
        systemDiskType?: pulumi.Input<string>;
        userData?: pulumi.Input<string>;
    }

    export interface ScaleWorkerWorkerConfigDataDisk {
        autoFormatAndMount?: pulumi.Input<boolean>;
        diskPartition?: pulumi.Input<string>;
        diskSize?: pulumi.Input<number>;
        diskType?: pulumi.Input<string>;
        encrypt?: pulumi.Input<boolean>;
        fileSystem?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        mountTarget?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
    }

    export interface ScaleWorkerWorkerInstancesList {
        failedReason?: pulumi.Input<string>;
        instanceId?: pulumi.Input<string>;
        instanceRole?: pulumi.Input<string>;
        instanceState?: pulumi.Input<string>;
        lanIp?: pulumi.Input<string>;
    }

}

export namespace Vod {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        audio: pulumi.Input<inputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoAudio>;
        removeAudio?: pulumi.Input<boolean>;
        video: pulumi.Input<inputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoVideo>;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        audioChannel?: pulumi.Input<string>;
        bitrate: pulumi.Input<number>;
        codec: pulumi.Input<string>;
        sampleRate: pulumi.Input<number>;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        bitrate: pulumi.Input<number>;
        codec: pulumi.Input<string>;
        fillType?: pulumi.Input<string>;
        fps: pulumi.Input<number>;
        height?: pulumi.Input<number>;
        resolutionAdaptive?: pulumi.Input<boolean>;
        width?: pulumi.Input<number>;
    }

    export interface ProcedureTemplateMediaProcessTask {
        adaptiveDynamicStreamingTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList>[]>;
        animatedGraphicTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList>[]>;
        coverBySnapshotTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList>[]>;
        imageSpriteTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskImageSpriteTaskList>[]>;
        sampleSnapshotTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList>[]>;
        snapshotByTimeOffsetTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList>[]>;
        transcodeTaskLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        definition: pulumi.Input<string>;
        watermarkLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        definition: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        startTimeOffset?: pulumi.Input<number>;
        svgContent?: pulumi.Input<string>;
        textContent?: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList {
        definition: pulumi.Input<string>;
        endTimeOffset: pulumi.Input<number>;
        startTimeOffset: pulumi.Input<number>;
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList {
        definition: pulumi.Input<string>;
        positionType: pulumi.Input<string>;
        positionValue: pulumi.Input<number>;
        watermarkLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        definition: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        startTimeOffset?: pulumi.Input<number>;
        svgContent?: pulumi.Input<string>;
        textContent?: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskImageSpriteTaskList {
        definition: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList {
        definition: pulumi.Input<string>;
        watermarkLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        definition: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        startTimeOffset?: pulumi.Input<number>;
        svgContent?: pulumi.Input<string>;
        textContent?: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList {
        definition: pulumi.Input<string>;
        extTimeOffsetLists?: pulumi.Input<pulumi.Input<string>[]>;
        watermarkLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        definition: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        startTimeOffset?: pulumi.Input<number>;
        svgContent?: pulumi.Input<string>;
        textContent?: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskList {
        definition: pulumi.Input<string>;
        mosaicLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList>[]>;
        watermarkLists?: pulumi.Input<pulumi.Input<inputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList>[]>;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList {
        coordinateOrigin?: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        height?: pulumi.Input<string>;
        startTimeOffset?: pulumi.Input<number>;
        width?: pulumi.Input<string>;
        xPos?: pulumi.Input<string>;
        yPos?: pulumi.Input<string>;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList {
        definition: pulumi.Input<string>;
        endTimeOffset?: pulumi.Input<number>;
        startTimeOffset?: pulumi.Input<number>;
        svgContent?: pulumi.Input<string>;
        textContent?: pulumi.Input<string>;
    }

    export interface SuperPlayerConfigDrmStreamingInfo {
        simpleAesDefinition?: pulumi.Input<string>;
    }

    export interface SuperPlayerConfigResolutionName {
        minEdgeLength: pulumi.Input<number>;
        name: pulumi.Input<string>;
    }

}

export namespace Vpc {
}

export namespace Vpn {
    export interface ConnectionSecurityGroupPolicy {
        localCidrBlock: pulumi.Input<string>;
        remoteCidrBlocks: pulumi.Input<pulumi.Input<string>[]>;
    }

}

export namespace config {
}
