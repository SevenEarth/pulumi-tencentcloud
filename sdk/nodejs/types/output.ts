// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export namespace APIGateway {
    export interface APIRequestParameter {
        defaultValue?: string;
        desc?: string;
        name: string;
        position: string;
        required?: boolean;
        type: string;
    }

    export interface APIResponseErrorCode {
        code: number;
        convertedCode?: number;
        desc?: string;
        msg: string;
        needConvert?: boolean;
    }

    export interface ServiceApiList {
        apiDesc: string;
        apiId: string;
        apiName: string;
        method: string;
        path: string;
    }

    export interface ServiceUsagePlanList {
        apiId: string;
        bindType: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface UsagePlanAttachList {
        apiId: string;
        apiName: string;
        createTime: string;
        environment: string;
        method: string;
        modifyTime: string;
        path: string;
        serviceId: string;
        serviceName: string;
    }

}

export namespace Address {
    export interface TemplateGroupsGroupList {
        id: string;
        name: string;
        templateIds: string[];
    }

    export interface TemplatesTemplateList {
        addresses: string[];
        id: string;
        name: string;
    }

}

export namespace Api {
    export interface AvailabilityRegionsRegion {
        description: string;
        name: string;
        state: string;
    }

}

export namespace As {
    export interface ScalingConfigDataDisk {
        deleteWithInstance?: boolean;
        diskSize?: number;
        diskType?: string;
        snapshotId?: string;
    }

    export interface ScalingConfigInstanceNameSettings {
        instanceName: string;
        instanceNameStyle?: string;
    }

    export interface ScalingConfigsConfigurationList {
        configurationId: string;
        configurationName: string;
        createTime: string;
        dataDisks: outputs.As.ScalingConfigsConfigurationListDataDisk[];
        diskTypePolicy: string;
        enhancedMonitorService: boolean;
        enhancedSecurityService: boolean;
        imageId: string;
        instanceTags: {[key: string]: any};
        instanceTypes: string[];
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        keyIds: string[];
        projectId: number;
        publicIpAssigned: boolean;
        securityGroupIds: string[];
        status: string;
        systemDiskSize: number;
        systemDiskType: string;
        userData: string;
    }

    export interface ScalingConfigsConfigurationListDataDisk {
        deleteWithInstance: boolean;
        diskSize: number;
        diskType: string;
        snapshotId: string;
    }

    export interface ScalingGroupForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        ruleId?: string;
        targetAttributes: outputs.As.ScalingGroupForwardBalancerIdTargetAttribute[];
    }

    export interface ScalingGroupForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

    export interface ScalingGroupsScalingGroupList {
        configurationId: string;
        createTime: string;
        defaultCooldown: number;
        desiredCapacity: number;
        forwardBalancerIds: outputs.As.ScalingGroupsScalingGroupListForwardBalancerId[];
        instanceCount: number;
        loadBalancerIds: string[];
        maxSize: number;
        minSize: number;
        multiZoneSubnetPolicy: string;
        projectId: number;
        retryPolicy: string;
        scalingGroupId: string;
        scalingGroupName: string;
        status: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        terminationPolicies: string[];
        vpcId: string;
        zones: string[];
    }

    export interface ScalingGroupsScalingGroupListForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        locationId: string;
        targetAttributes: outputs.As.ScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute[];
    }

    export interface ScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

    export interface ScalingPoliciesScalingPolicyList {
        adjustmentType: string;
        adjustmentValue: number;
        comparisonOperator: string;
        continuousTime: number;
        cooldown: number;
        metricName: string;
        notificationUserGroupIds: string[];
        period: number;
        policyName: string;
        scalingGroupId: string;
        statistic: string;
        threshold: number;
    }

}

export namespace Audit {
    export interface CosRegionsAuditCosRegionList {
        cosRegion: string;
        cosRegionName: string;
    }

    export interface KeyAliasAuditKeyAliasList {
        keyAlias: string;
        keyId: string;
    }

}

export namespace Audits {
    export interface InstancesAuditList {
        auditSwitch: boolean;
        cosBucket: string;
        id: string;
        logFilePrefix: string;
        name: string;
    }

}

export namespace Availability {
    export interface ZonesByProductZone {
        description: string;
        id: string;
        name: string;
        state: string;
    }

    export interface ZonesZone {
        description: string;
        id: string;
        name: string;
        state: string;
    }

}

export namespace Cam {
    export interface GroupMembershipsMembershipList {
        groupId: string;
        /**
         * @deprecated It has been deprecated from version 1.59.5. Use `user_names` instead.
         */
        userIds: string[];
        userNames: string[];
    }

    export interface GroupPolicyAttachmentsGroupPolicyAttachmentList {
        createMode: number;
        createTime: string;
        groupId: string;
        policyId: string;
        policyName: string;
        policyType: string;
    }

    export interface GroupsGroupList {
        createTime: string;
        groupId: string;
        name: string;
        remark: string;
    }

    export interface PoliciesPolicyList {
        attachments: number;
        createMode: number;
        createTime: string;
        description: string;
        name: string;
        policyId: string;
        serviceType: string;
        type: number;
    }

    export interface RolePolicyAttachmentsRolePolicyAttachmentList {
        createMode: number;
        createTime: string;
        policyId: string;
        policyName: string;
        policyType: string;
        roleId: string;
    }

    export interface RolesRoleList {
        consoleLogin: boolean;
        createTime: string;
        description: string;
        document: string;
        name: string;
        roleId: string;
        updateTime: string;
    }

    export interface SAMLProvidersProviderList {
        createTime: string;
        description: string;
        modifyTime: string;
        name: string;
    }

    export interface UserPolicyAttachmentsUserPolicyAttachmentList {
        createMode: number;
        createTime: string;
        policyId: string;
        policyName: string;
        policyType: string;
        /**
         * @deprecated It has been deprecated from version 1.59.6. Use `user_name` instead.
         */
        userId: string;
        userName: string;
    }

    export interface UsersUserList {
        consoleLogin?: boolean;
        countryCode: string;
        email: string;
        name: string;
        phoneNum: string;
        remark: string;
        uid: number;
        uin: number;
        userId: string;
    }

}

export namespace Cbs {
    export interface SnapshotPoliciesSnapshotPolicyList {
        attachedStorageIds: string[];
        createTime: string;
        repeatHours: number[];
        repeatWeekdays: number[];
        retentionDays: number;
        snapshotPolicyId: string;
        snapshotPolicyName: string;
        status: string;
    }

    export interface SnapshotsSnapshotList {
        availabilityZone: string;
        createTime: string;
        encrypt: boolean;
        percent: number;
        projectId: number;
        snapshotId: string;
        snapshotName: string;
        storageId: string;
        storageSize: number;
        storageUsage: string;
    }

    export interface StoragesStorageList {
        attached: boolean;
        availabilityZone: string;
        chargeType: string;
        createTime: string;
        encrypt: boolean;
        instanceId: string;
        prepaidRenewFlag: string;
        projectId: number;
        status: string;
        storageId: string;
        storageName: string;
        storageSize: number;
        storageType: string;
        storageUsage: string;
        tags: {[key: string]: any};
        throughputPerformance: number;
    }

}

export namespace Ccn {
    export interface BandwidthLimitsLimit {
        bandwidthLimit: number;
        dstRegion: string;
        region: string;
    }

    export interface InstancesInstanceList {
        attachmentLists: outputs.Ccn.InstancesInstanceListAttachmentList[];
        bandwidthLimitType: string;
        ccnId: string;
        chargeType: string;
        createTime: string;
        description: string;
        name: string;
        qos: string;
        state: string;
    }

    export interface InstancesInstanceListAttachmentList {
        attachedTime: string;
        cidrBlocks: string[];
        instanceId: string;
        instanceRegion: string;
        instanceType: string;
        state: string;
    }

}

export namespace Cdh {
    export interface InstanceHostResource {
        cpuAvailableNum: number;
        cpuTotalNum: number;
        diskAvailableSize: number;
        diskTotalSize: number;
        diskType: string;
        memoryAvailableSize: number;
        memoryTotalSize: number;
    }

    export interface InstancesCdhInstanceList {
        availabilityZone: string;
        cageId: string;
        chargeType: string;
        createTime: string;
        cvmInstanceIds: string[];
        expiredTime: string;
        hostId: string;
        hostName: string;
        hostResources: outputs.Cdh.InstancesCdhInstanceListHostResource[];
        hostState: string;
        hostType: string;
        prepaidRenewFlag: string;
        projectId: number;
    }

    export interface InstancesCdhInstanceListHostResource {
        cpuAvailableNum: number;
        cpuTotalNum: number;
        diskAvailableSize: number;
        diskTotalSize: number;
        diskType: string;
        memoryAvailableSize: number;
        memoryTotalSize: number;
    }

}

export namespace Cdn {
    export interface CdnDomainAuthentication {
        switch?: string;
        typeA?: outputs.Cdn.CdnDomainAuthenticationTypeA;
        typeB?: outputs.Cdn.CdnDomainAuthenticationTypeB;
        typeC?: outputs.Cdn.CdnDomainAuthenticationTypeC;
        typeD?: outputs.Cdn.CdnDomainAuthenticationTypeD;
    }

    export interface CdnDomainAuthenticationTypeA {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        signParam: string;
    }

    export interface CdnDomainAuthenticationTypeB {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
    }

    export interface CdnDomainAuthenticationTypeC {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        timeFormat?: string;
    }

    export interface CdnDomainAuthenticationTypeD {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        timeFormat?: string;
        timeParam?: string;
    }

    export interface CdnDomainAwsPrivateAccess {
        accessKey?: string;
        bucket?: string;
        region?: string;
        secretKey?: string;
        switch: string;
    }

    export interface CdnDomainBandWidthAlert {
        alertPercentage?: number;
        alertSwitch?: string;
        bpsThreshold?: number;
        counterMeasure?: string;
        lastTriggerTime: string;
        lastTriggerTimeOverseas: string;
        metric?: string;
        statisticItem?: outputs.Cdn.CdnDomainBandWidthAlertStatisticItem;
        switch: string;
    }

    export interface CdnDomainBandWidthAlertStatisticItem {
        alertPercentage?: number;
        alertSwitch?: string;
        bpsThreshold?: number;
        counterMeasure?: string;
        cycle?: number;
        metric?: string;
        switch: string;
        type?: string;
        unblockTime?: number;
    }

    export interface CdnDomainCompression {
        compressionRules?: outputs.Cdn.CdnDomainCompressionCompressionRule[];
        switch: string;
    }

    export interface CdnDomainCompressionCompressionRule {
        algorithms: string[];
        compress: boolean;
        fileExtensions?: string[];
        maxLength: number;
        minLength: number;
        rulePaths?: string[];
        ruleType?: string;
    }

    export interface CdnDomainDownstreamCapping {
        cappingRules?: outputs.Cdn.CdnDomainDownstreamCappingCappingRule[];
        switch: string;
    }

    export interface CdnDomainDownstreamCappingCappingRule {
        kbpsThreshold: number;
        rulePaths: string[];
        ruleType: string;
    }

    export interface CdnDomainErrorPage {
        pageRules?: outputs.Cdn.CdnDomainErrorPagePageRule[];
        switch: string;
    }

    export interface CdnDomainErrorPagePageRule {
        redirectCode: number;
        redirectUrl: string;
        statusCode: number;
    }

    export interface CdnDomainHttpsConfig {
        clientCertificateConfig?: outputs.Cdn.CdnDomainHttpsConfigClientCertificateConfig;
        forceRedirect: outputs.Cdn.CdnDomainHttpsConfigForceRedirect;
        http2Switch?: string;
        httpsSwitch: string;
        ocspStaplingSwitch?: string;
        serverCertificateConfig?: outputs.Cdn.CdnDomainHttpsConfigServerCertificateConfig;
        spdySwitch?: string;
        verifyClient?: string;
    }

    export interface CdnDomainHttpsConfigClientCertificateConfig {
        certificateContent: string;
        certificateName: string;
        deployTime: string;
        expireTime: string;
    }

    export interface CdnDomainHttpsConfigForceRedirect {
        redirectStatusCode?: number;
        redirectType?: string;
        switch?: string;
    }

    export interface CdnDomainHttpsConfigServerCertificateConfig {
        certificateContent?: string;
        certificateId?: string;
        certificateName: string;
        deployTime: string;
        expireTime: string;
        message?: string;
        privateKey?: string;
    }

    export interface CdnDomainHwPrivateAccess {
        accessKey?: string;
        bucket?: string;
        secretKey?: string;
        switch: string;
    }

    export interface CdnDomainIpFilter {
        filterRules?: outputs.Cdn.CdnDomainIpFilterFilterRule[];
        filterType?: string;
        filters?: string[];
        returnCode?: number;
        switch: string;
    }

    export interface CdnDomainIpFilterFilterRule {
        filterType: string;
        filters: string[];
        rulePaths: string[];
        ruleType: string;
    }

    export interface CdnDomainIpFreqLimit {
        qps?: number;
        switch: string;
    }

    export interface CdnDomainMaxAge {
        maxAgeRules?: outputs.Cdn.CdnDomainMaxAgeMaxAgeRule[];
        switch: string;
    }

    export interface CdnDomainMaxAgeMaxAgeRule {
        followOrigin?: string;
        maxAgeContents: string[];
        maxAgeTime: number;
        maxAgeType: string;
    }

    export interface CdnDomainOrigin {
        backupOriginLists?: string[];
        backupOriginType?: string;
        backupServerName?: string;
        cosPrivateAccess?: string;
        originLists: string[];
        originPullProtocol?: string;
        originType: string;
        serverName: string;
    }

    export interface CdnDomainOriginPullOptimization {
        optimizationType?: string;
        switch: string;
    }

    export interface CdnDomainOriginPullTimeout {
        connectTimeout: number;
        receiveTimeout: number;
    }

    export interface CdnDomainOssPrivateAccess {
        accessKey?: string;
        bucket?: string;
        region?: string;
        secretKey?: string;
        switch: string;
    }

    export interface CdnDomainQnPrivateAccess {
        accessKey?: string;
        secretKey?: string;
        switch: string;
    }

    export interface CdnDomainReferer {
        refererRules?: outputs.Cdn.CdnDomainRefererRefererRule[];
        switch: string;
    }

    export interface CdnDomainRefererRefererRule {
        allowEmpty: boolean;
        refererType: string;
        referers: string[];
        rulePaths: string[];
        ruleType: string;
    }

    export interface CdnDomainRequestHeader {
        headerRules?: outputs.Cdn.CdnDomainRequestHeaderHeaderRule[];
        switch?: string;
    }

    export interface CdnDomainRequestHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface CdnDomainResponseHeader {
        headerRules?: outputs.Cdn.CdnDomainResponseHeaderHeaderRule[];
        switch: string;
    }

    export interface CdnDomainResponseHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface CdnDomainRuleCach {
        cacheTime: number;
        compareMaxAge?: string;
        followOriginSwitch?: string;
        ignoreCacheControl?: string;
        ignoreSetCookie?: string;
        noCacheSwitch?: string;
        reValidate?: string;
        rulePaths: string[];
        ruleType?: string;
        switch?: string;
    }

    export interface CdnDomainStatusCodeCache {
        cacheRules?: outputs.Cdn.CdnDomainStatusCodeCacheCacheRule[];
        switch: string;
    }

    export interface CdnDomainStatusCodeCacheCacheRule {
        cacheTime: number;
        statusCode: string;
    }

    export interface DomainsDomainList {
        area: string;
        cname: string;
        createTime: string;
        domain: string;
        fullUrlCache: boolean;
        httpsConfigs: outputs.Cdn.DomainsDomainListHttpsConfig[];
        id: string;
        origins: outputs.Cdn.DomainsDomainListOrigin[];
        projectId: number;
        rangeOriginSwitch: string;
        requestHeaders: outputs.Cdn.DomainsDomainListRequestHeader[];
        ruleCaches: outputs.Cdn.DomainsDomainListRuleCach[];
        serviceType: string;
        status: string;
        tags: {[key: string]: any};
        updateTime: string;
    }

    export interface DomainsDomainListHttpsConfig {
        http2Switch: string;
        httpsSwitch: string;
        ocspStaplingSwitch: string;
        spdySwitch: string;
        verifyClient: string;
    }

    export interface DomainsDomainListOrigin {
        backupOriginLists: string[];
        backupOriginType: string;
        backupServerName: string;
        cosPrivateAccess: string;
        originLists: string[];
        originPullProtocol: string;
        originType: string;
        serverName: string;
    }

    export interface DomainsDomainListRequestHeader {
        headerRules: outputs.Cdn.DomainsDomainListRequestHeaderHeaderRule[];
        switch: string;
    }

    export interface DomainsDomainListRequestHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainsDomainListRuleCach {
        cacheTime: number;
        compareMaxAge?: string;
        followOriginSwitch: string;
        ignoreCacheControl?: string;
        ignoreSetCookie: string;
        noCacheSwitch: string;
        reValidate: string;
        rulePaths: string[];
        ruleType: string;
        switch: string;
    }

}

export namespace Cfs {
    export interface AccessGroupsAccessGroupList {
        accessGroupId: string;
        createTime: string;
        description: string;
        name: string;
    }

    export interface AccessRulesAccessRuleList {
        accessRuleId: string;
        authClientIp: string;
        priority: number;
        rwPermission: string;
        userPermission: string;
    }

    export interface FileSystemsFileSystemList {
        accessGroupId: string;
        availabilityZone: string;
        createTime: string;
        fileSystemId: string;
        name: string;
        protocol: string;
        sizeLimit: number;
        sizeUsed: number;
        status: string;
        storageType: string;
    }

}

export namespace Ckafka {
    export interface AclsAclList {
        host: string;
        operationType: string;
        permissionType: string;
        principal: string;
        resourceName: string;
        resourceType: string;
    }

    export interface InstanceConfig {
        autoCreateTopicEnable: boolean;
        defaultNumPartitions: number;
        defaultReplicationFactor: number;
    }

    export interface InstanceDynamicRetentionConfig {
        bottomRetention: number;
        diskQuotaPercentage: number;
        enable: number;
        stepForwardPercentage: number;
    }

    export interface InstanceTag {
        key: string;
        value: string;
    }

    export interface TopicsInstanceList {
        cleanUpPolicy: string;
        createTime: string;
        enableWhiteList: boolean;
        forwardCosBucket: string;
        forwardInterval: number;
        forwardStatus: number;
        ipWhiteListCount: number;
        maxMessageBytes: number;
        note: string;
        partitionNum: number;
        replicaNum: number;
        retention: number;
        segment: number;
        segmentBytes: number;
        syncReplicaMinNum: number;
        topicId: string;
        topicName: string;
        uncleanLeaderElectionEnable: boolean;
    }

    export interface UsersUserList {
        accountName: string;
        createTime: string;
        updateTime: string;
    }

}

export namespace Clb {
    export interface InstanceSnatIp {
        ip?: string;
        subnetId: string;
    }

    export interface InstancesClbList {
        addressIpVersion: string;
        clbId: string;
        clbName: string;
        clbVips: string[];
        createTime: string;
        internetBandwidthMaxOut: number;
        internetChargeType: string;
        localZone: boolean;
        networkType: string;
        projectId: number;
        securityGroups: string[];
        status: number;
        statusTime: string;
        subnetId: string;
        tags: {[key: string]: any};
        targetRegionInfoRegion: string;
        targetRegionInfoVpcId: string;
        vipIsp: string;
        vpcId: string;
        zone: string;
        zoneId: number;
        zoneName: string;
        zoneRegion: string;
    }

    export interface ListenerRulesRuleList {
        certificateCaId: string;
        certificateId: string;
        certificateSslMode: string;
        clbId: string;
        domain?: string;
        healthCheckHealthNum: number;
        healthCheckHttpCode: number;
        healthCheckHttpDomain: string;
        healthCheckHttpMethod: string;
        healthCheckHttpPath: string;
        healthCheckIntervalTime: number;
        healthCheckSwitch: boolean;
        healthCheckUnhealthNum: number;
        http2Switch: boolean;
        listenerId: string;
        ruleId: string;
        scheduler: string;
        sessionExpireTime: number;
        url?: string;
    }

    export interface ListenersListenerList {
        certificateCaId: string;
        certificateId: string;
        certificateSslMode: string;
        clbId: string;
        healthCheckContextType: string;
        healthCheckHealthNum: number;
        healthCheckHttpCode: number;
        healthCheckHttpDomain: string;
        healthCheckHttpMethod: string;
        healthCheckHttpPath: string;
        healthCheckHttpVersion: string;
        healthCheckIntervalTime: number;
        healthCheckPort: number;
        healthCheckRecvContext: string;
        healthCheckSendContext: string;
        healthCheckSwitch: boolean;
        healthCheckTimeOut: number;
        healthCheckType: string;
        healthCheckUnhealthNum: number;
        listenerId: string;
        listenerName: string;
        port: number;
        protocol: string;
        scheduler: string;
        sessionExpireTime: number;
        sniSwitch: boolean;
    }

    export interface RedirectionsRedirectionList {
        clbId: string;
        sourceListenerId: string;
        sourceRuleId: string;
        targetListenerId: string;
        targetRuleId: string;
    }

    export interface ServerAttachmentTarget {
        eniIp?: string;
        instanceId?: string;
        port: number;
        weight?: number;
    }

    export interface ServerAttachmentsAttachmentList {
        clbId: string;
        listenerId: string;
        protocolType: string;
        ruleId: string;
        targets: outputs.Clb.ServerAttachmentsAttachmentListTarget[];
    }

    export interface ServerAttachmentsAttachmentListTarget {
        instanceId: string;
        port: number;
        weight: number;
    }

    export interface TargetGroupTargetGroupInstance {
        bindIp: string;
        newPort?: number;
        port: number;
        weight?: number;
    }

    export interface TargetGroupsList {
        associatedRuleLists: outputs.Clb.TargetGroupsListAssociatedRuleList[];
        createTime: string;
        port: number;
        targetGroupId: string;
        targetGroupInstanceLists: outputs.Clb.TargetGroupsListTargetGroupInstanceList[];
        targetGroupName: string;
        updateTime: string;
        vpcId: string;
    }

    export interface TargetGroupsListAssociatedRuleList {
        domain: string;
        listenerId: string;
        listenerName: string;
        listenerPort: number;
        loadBalancerId: string;
        loadBalancerName: string;
        locationId: string;
        protocol: string;
        url: string;
    }

    export interface TargetGroupsListTargetGroupInstanceList {
        eniId: string;
        instanceId: string;
        instanceName: string;
        privateIpAddresses: any[];
        publicIpAddresses: any[];
        registeredTime: string;
        serverPort: number;
        serverType: string;
        weight: number;
    }

}

export namespace Cloud {
    export interface APIGatewayAPIKeysList {
        accessKeySecret: string;
        apiKeyId: string;
        createTime: string;
        modifyTime: string;
        status: string;
    }

    export interface APIGatewayAPIsList {
        apiDesc: string;
        apiName: string;
        authType: string;
        createTime: string;
        enableCors: boolean;
        modifyTime: string;
        protocol: string;
        requestConfigMethod: string;
        requestConfigPath: string;
        requestParameters: outputs.Cloud.APIGatewayAPIsListRequestParameter[];
        responseErrorCodes: outputs.Cloud.APIGatewayAPIsListResponseErrorCode[];
        responseFailExample: string;
        responseSuccessExample: string;
        responseType: string;
        serviceConfigMethod: string;
        serviceConfigMockReturnMessage: string;
        serviceConfigPath: string;
        serviceConfigProduct: string;
        serviceConfigScfFunctionName: string;
        serviceConfigScfFunctionNamespace: string;
        serviceConfigScfFunctionQualifier: string;
        serviceConfigTimeout: number;
        serviceConfigType: string;
        serviceConfigUrl: string;
        serviceConfigVpcId: string;
        serviceId: string;
    }

    export interface APIGatewayAPIsListRequestParameter {
        defaultValue: string;
        desc: string;
        name: string;
        position: string;
        required: boolean;
        type: string;
    }

    export interface APIGatewayAPIsListResponseErrorCode {
        code: number;
        convertedCode: number;
        desc: string;
        msg: string;
        needConvert: boolean;
    }

    export interface APIGatewayCustomerDomainsList {
        certificateId: string;
        domainName: string;
        isDefaultMapping: boolean;
        isStatusOn: boolean;
        netType: string;
        pathMappings: outputs.Cloud.APIGatewayCustomerDomainsListPathMapping[];
        protocol: string;
    }

    export interface APIGatewayCustomerDomainsListPathMapping {
        environment: string;
        path: string;
    }

    export interface APIGatewayIpStrategyList {
        attachLists: outputs.Cloud.APIGatewayIpStrategyListAttachList[];
        bindApiTotalCount: number;
        createTime: string;
        ipList: string;
        modifyTime: string;
        serviceId: string;
        strategyId: string;
        strategyName: string;
        strategyType: string;
    }

    export interface APIGatewayIpStrategyListAttachList {
        apiBusinessType: string;
        apiDesc: string;
        apiId: string;
        apiName: string;
        apiType: string;
        authRelationApiId: string;
        authType: string;
        createTime: string;
        method: string;
        modifyTime: string;
        oauthConfig: {[key: string]: any};
        path: string;
        protocol: string;
        relationBusinessApiIds: string[];
        serviceId: string;
        tags: string[];
        uniqVpcId: string;
        vpcId: number;
    }

    export interface APIGatewayServicesList {
        createTime: string;
        exclusiveSetName: string;
        innerHttpPort: number;
        innerHttpsPort: number;
        internalSubDomain: string;
        ipVersion: string;
        modifyTime: string;
        netTypes: string[];
        outerSubDomain: string;
        protocol: string;
        serviceDesc: string;
        serviceId: string;
        serviceName: string;
        usagePlanLists: outputs.Cloud.APIGatewayServicesListUsagePlanList[];
    }

    export interface APIGatewayServicesListUsagePlanList {
        apiId: string;
        bindType: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface APIGatewayThrottlingApisList {
        apiEnvironmentStrategies: outputs.Cloud.APIGatewayThrottlingApisListApiEnvironmentStrategy[];
        serviceId: string;
    }

    export interface APIGatewayThrottlingApisListApiEnvironmentStrategy {
        apiId: string;
        apiName: string;
        method: string;
        path: string;
        strategyLists: outputs.Cloud.APIGatewayThrottlingApisListApiEnvironmentStrategyStrategyList[];
    }

    export interface APIGatewayThrottlingApisListApiEnvironmentStrategyStrategyList {
        environmentName: string;
        quota: number;
    }

    export interface APIGatewayThrottlingServicesList {
        environments: outputs.Cloud.APIGatewayThrottlingServicesListEnvironment[];
        serviceId: string;
    }

    export interface APIGatewayThrottlingServicesListEnvironment {
        environmentName: string;
        status: number;
        strategy: number;
        url: string;
        versionName: string;
    }

    export interface APIGatewayUsagePlanEnvironmentsList {
        apiId: string;
        apiName: string;
        createTime: string;
        environment: string;
        method: string;
        modifyTime: string;
        path: string;
        serviceId: string;
        serviceName: string;
    }

    export interface APIGatewayUsagePlansList {
        createTime: string;
        maxRequestNum: number;
        maxRequestNumPreSec: number;
        modifyTime: string;
        usagePlanDesc: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface TCRInstancesInstanceList {
        id: string;
        instanceType: string;
        internalEndPoint: string;
        name: string;
        publicDomain: string;
        status: string;
        tags: {[key: string]: any};
    }

    export interface TCRNamespacesNamespaceList {
        isPublic: boolean;
        name: string;
    }

    export interface TCRRepositoriesRepositoryList {
        briefDesc: string;
        createTime: string;
        description: string;
        isPublic: boolean;
        name: string;
        namespaceName: string;
        updateTime: string;
        url: string;
    }

    export interface TCRTokensTokenList {
        createTime: string;
        description: string;
        enable: boolean;
        tokenId: string;
    }

    export interface TCRVPCAttachmentsVpcAttachmentList {
        accessIp: string;
        enablePublicDomainDns: boolean;
        enableVpcDomainDns: boolean;
        status: string;
        subnetId: string;
        vpcId: string;
    }

}

export namespace Cls {
    export interface ConfigExcludePath {
        type?: string;
        value?: string;
    }

    export interface ConfigExtraContainerFile {
        container: string;
        excludeLabels?: string[];
        excludeNamespace?: string;
        filePattern: string;
        includeLabels?: string[];
        logPath: string;
        namespace: string;
        workload?: outputs.Cls.ConfigExtraContainerFileWorkload;
    }

    export interface ConfigExtraContainerFileWorkload {
        container?: string;
        kind: string;
        name: string;
        namespace?: string;
    }

    export interface ConfigExtraContainerStdout {
        allContainers: boolean;
        excludeLabels?: string[];
        excludeNamespace?: string;
        includeLabels?: string[];
        namespace?: string;
        workloads?: outputs.Cls.ConfigExtraContainerStdoutWorkload[];
    }

    export interface ConfigExtraContainerStdoutWorkload {
        container?: string;
        kind: string;
        name: string;
        namespace?: string;
    }

    export interface ConfigExtraExcludePath {
        type?: string;
        value?: string;
    }

    export interface ConfigExtraExtractRule {
        backtracking?: number;
        beginRegex?: string;
        delimiter?: string;
        filterKeyRegexes?: outputs.Cls.ConfigExtraExtractRuleFilterKeyRegex[];
        keys?: string[];
        logRegex?: string;
        timeFormat?: string;
        timeKey?: string;
        unMatchLogKey?: string;
        unMatchUpLoadSwitch?: boolean;
    }

    export interface ConfigExtraExtractRuleFilterKeyRegex {
        key?: string;
        regex?: string;
    }

    export interface ConfigExtraHostFile {
        customLabels?: string[];
        filePattern: string;
        logPath: string;
    }

    export interface ConfigExtractRule {
        backtracking?: number;
        beginRegex?: string;
        delimiter?: string;
        filterKeyRegexes?: outputs.Cls.ConfigExtractRuleFilterKeyRegex[];
        keys?: string[];
        logRegex?: string;
        timeFormat?: string;
        timeKey?: string;
        unMatchLogKey?: string;
        unMatchUpLoadSwitch?: boolean;
    }

    export interface ConfigExtractRuleFilterKeyRegex {
        key?: string;
        regex?: string;
    }

    export interface CosShipperCompress {
        format: string;
    }

    export interface CosShipperContent {
        csv?: outputs.Cls.CosShipperContentCsv;
        format: string;
        json?: outputs.Cls.CosShipperContentJson;
    }

    export interface CosShipperContentCsv {
        delimiter: string;
        escapeChar: string;
        keys: string[];
        nonExistingField: string;
        printKey: boolean;
    }

    export interface CosShipperContentJson {
        enableTag: boolean;
        metaFields: string[];
    }

    export interface CosShipperFilterRule {
        key: string;
        regex: string;
        value: string;
    }

    export interface MachineGroupMachineGroupType {
        type: string;
        values: string[];
    }

}

export namespace Container {
    export interface ClusterInstancesNode {
        abnormalReason: string;
        cpu: number;
        instanceId: string;
        isNormal: number;
        lanIp: string;
        mem: number;
        wanIp: string;
    }

    export interface ClustersCluster {
        clusterId: string;
        clusterName: string;
        description: string;
        kubernetesVersion: string;
        nodesNum: number;
        nodesStatus: string;
        securityCertificationAuthority: string;
        securityClusterExternalEndpoint: string;
        securityPassword: string;
        securityUsername: string;
        totalCpu: number;
        totalMem: number;
    }

}

export namespace Cos {
    export interface BucketsBucketList {
        acl: string;
        aclBody: string;
        bucket: string;
        corsRules: outputs.Cos.BucketsBucketListCorsRule[];
        cosBucketUrl: string;
        lifecycleRules: outputs.Cos.BucketsBucketListLifecycleRule[];
        originDomainRules: outputs.Cos.BucketsBucketListOriginDomainRule[];
        originPullRules: outputs.Cos.BucketsBucketListOriginPullRule[];
        tags: {[key: string]: any};
        websites: outputs.Cos.BucketsBucketListWebsite[];
    }

    export interface BucketsBucketListCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders: string[];
        maxAgeSeconds: number;
    }

    export interface BucketsBucketListLifecycleRule {
        expirations: outputs.Cos.BucketsBucketListLifecycleRuleExpiration[];
        filterPrefix: string;
        nonCurrentExpirations: outputs.Cos.BucketsBucketListLifecycleRuleNonCurrentExpiration[];
        nonCurrentTransitions: outputs.Cos.BucketsBucketListLifecycleRuleNonCurrentTransition[];
        transitions: outputs.Cos.BucketsBucketListLifecycleRuleTransition[];
    }

    export interface BucketsBucketListLifecycleRuleExpiration {
        date: string;
        days: number;
    }

    export interface BucketsBucketListLifecycleRuleNonCurrentExpiration {
        nonCurrentDays: number;
    }

    export interface BucketsBucketListLifecycleRuleNonCurrentTransition {
        nonCurrentDays: number;
        storageClass: string;
    }

    export interface BucketsBucketListLifecycleRuleTransition {
        date: string;
        days: number;
        storageClass: string;
    }

    export interface BucketsBucketListOriginDomainRule {
        domain: string;
        status?: string;
        type?: string;
    }

    export interface BucketsBucketListOriginPullRule {
        customHttpHeaders?: {[key: string]: any};
        followHttpHeaders?: string[];
        followQueryString?: boolean;
        followRedirection?: boolean;
        host: string;
        prefix?: string;
        priority: number;
        protocol?: string;
        syncBackToSource?: boolean;
    }

    export interface BucketsBucketListWebsite {
        errorDocument: string;
        indexDocument: string;
    }

    export interface CosBucketCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }

    export interface CosBucketLifecycleRule {
        expiration?: outputs.Cos.CosBucketLifecycleRuleExpiration;
        filterPrefix: string;
        id?: string;
        nonCurrentExpiration?: outputs.Cos.CosBucketLifecycleRuleNonCurrentExpiration;
        nonCurrentTransitions?: outputs.Cos.CosBucketLifecycleRuleNonCurrentTransition[];
        transitions?: outputs.Cos.CosBucketLifecycleRuleTransition[];
    }

    export interface CosBucketLifecycleRuleExpiration {
        date?: string;
        days?: number;
        deleteMarker?: boolean;
    }

    export interface CosBucketLifecycleRuleNonCurrentExpiration {
        nonCurrentDays?: number;
    }

    export interface CosBucketLifecycleRuleNonCurrentTransition {
        nonCurrentDays?: number;
        storageClass: string;
    }

    export interface CosBucketLifecycleRuleTransition {
        date?: string;
        days?: number;
        storageClass: string;
    }

    export interface CosBucketOriginDomainRule {
        domain: string;
        status?: string;
        type?: string;
    }

    export interface CosBucketOriginPullRule {
        customHttpHeaders?: {[key: string]: any};
        followHttpHeaders?: string[];
        followQueryString?: boolean;
        followRedirection?: boolean;
        host: string;
        prefix?: string;
        priority: number;
        protocol?: string;
        syncBackToSource?: boolean;
    }

    export interface CosBucketReplicaRule {
        destinationBucket: string;
        destinationStorageClass?: string;
        id?: string;
        prefix?: string;
        status: string;
    }

    export interface CosBucketWebsite {
        errorDocument?: string;
        indexDocument?: string;
    }

}

export namespace Cvm {
    export interface ImagesImage {
        architecture: string;
        createdTime: string;
        imageCreator: string;
        imageDescription: string;
        imageId: string;
        imageName: string;
        imageSize: number;
        imageSource: string;
        imageState: string;
        imageType: string;
        osName: string;
        platform: string;
        snapshots: outputs.Cvm.ImagesImageSnapshot[];
        supportCloudInit: boolean;
        syncPercent: number;
    }

    export interface ImagesImageSnapshot {
        diskSize: number;
        diskUsage: string;
        snapshotId: string;
        snapshotName: string;
    }

    export interface InstanceDataDisk {
        dataDiskId: string;
        dataDiskSize: number;
        dataDiskSnapshotId?: string;
        dataDiskType: string;
        deleteWithInstance?: boolean;
        encrypt?: boolean;
        throughputPerformance?: number;
    }

    export interface InstancesTypesFilter {
        name: string;
        values: string[];
    }

    export interface InstancesTypesInstanceType {
        availabilityZone: string;
        cpuCoreCount: number;
        family: string;
        gpuCoreCount: number;
        instanceChargeType: string;
        instanceType: string;
        memorySize: number;
        status: string;
    }

    export interface ReservedInstanceConfigsConfigList {
        availabilityZone: string;
        configId: string;
        currencyCode: string;
        duration: number;
        instanceType: string;
        offeringType: string;
        platform: string;
        price: number;
        usagePrice: number;
    }

}

export namespace Cynosdb {
    export interface ClusterParamItem {
        currentValue: string;
        name: string;
        oldValue?: string;
    }

    export interface ClusterRoGroupAddr {
        ip: string;
        port: number;
    }

    export interface ClusterRoGroupInstance {
        instanceId: string;
        instanceName: string;
    }

    export interface ClusterRwGroupAddr {
        ip: string;
        port: number;
    }

    export interface ClusterRwGroupInstance {
        instanceId: string;
        instanceName: string;
    }

    export interface ClustersClusterList {
        autoRenewFlag: number;
        availableZone: string;
        chargeType: string;
        clusterId: string;
        clusterLimit: number;
        clusterName: string;
        clusterStatus: string;
        createTime: string;
        dbType: string;
        dbVersion: string;
        port: number;
        projectId: number;
        subnetId: string;
        vpcId: string;
    }

    export interface InstancesInstanceList {
        clusterId?: string;
        createTime: string;
        instanceCpuCore: number;
        instanceId?: string;
        instanceMemorySize: number;
        instanceName: string;
        instanceStatus: string;
        instanceStorageSize: number;
        instanceType: string;
    }

}

export namespace Dayu {
    export interface CCHttpPoliciesList {
        action: string;
        createTime: string;
        frequency: number;
        ipLists: string[];
        name: string;
        policyId: string;
        resourceId: string;
        resourceType: string;
        ruleLists: outputs.Dayu.CCHttpPoliciesListRuleList[];
        smode: string;
        switch: boolean;
    }

    export interface CCHttpPoliciesListRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface CCHttpPolicyRuleList {
        operator?: string;
        skey?: string;
        value?: string;
    }

    export interface CCHttpsPoliciesList {
        action: string;
        createTime: string;
        domain: string;
        ipLists: string[];
        name: string;
        policyId: string;
        resourceId: string;
        resourceType: string;
        ruleId: string;
        ruleLists: outputs.Dayu.CCHttpsPoliciesListRuleList[];
        switch: boolean;
    }

    export interface CCHttpsPoliciesListRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface CCHttpsPolicyRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface CCPolicyV2CcBlackWhiteIp {
        blackWhiteIp: string;
        createTime: string;
        domain: string;
        modifyTime: string;
        protocol: string;
        type: string;
    }

    export interface CCPolicyV2CcGeoIpPolicy {
        action: string;
        areaLists: number[];
        createTime: string;
        domain: string;
        modifyTime: string;
        protocol: string;
        regionType: string;
    }

    export interface CCPolicyV2CcPrecisionPolicy {
        domain: string;
        ip: string;
        policyAction: string;
        policyId: string;
        policys: outputs.Dayu.CCPolicyV2CcPrecisionPolicyPolicy[];
        protocol: string;
    }

    export interface CCPolicyV2CcPrecisionPolicyPolicy {
        fieldName: string;
        fieldType: string;
        value: string;
        valueOperator: string;
    }

    export interface CCPolicyV2CcPrecisionReqLimit {
        domain: string;
        instanceId: string;
        ip: string;
        level: string;
        policys: outputs.Dayu.CCPolicyV2CcPrecisionReqLimitPolicy[];
        protocol: string;
    }

    export interface CCPolicyV2CcPrecisionReqLimitPolicy {
        action: string;
        cookie?: string;
        executeDuration: number;
        mode: string;
        period: number;
        requestNum: number;
        uri?: string;
        userAgent?: string;
    }

    export interface CCPolicyV2Threshold {
        domain: string;
        threshold: number;
    }

    export interface DdosPoliciesList {
        blackIps?: string[];
        createTime: string;
        dropOptions: outputs.Dayu.DdosPoliciesListDropOption[];
        name: string;
        packetFilters: outputs.Dayu.DdosPoliciesListPacketFilter[];
        policyId: string;
        portFilters: outputs.Dayu.DdosPoliciesListPortFilter[];
        sceneId: string;
        watermarkFilters: outputs.Dayu.DdosPoliciesListWatermarkFilter[];
        watermarkKeys: outputs.Dayu.DdosPoliciesListWatermarkKey[];
        whiteIps?: string[];
    }

    export interface DdosPoliciesListDropOption {
        badConnThreshold: number;
        checkSyncConn: boolean;
        connTimeout: number;
        dConnLimit: number;
        dNewLimit: number;
        dropAbroad: boolean;
        dropIcmp: boolean;
        dropOther: boolean;
        dropTcp: boolean;
        dropUdp: boolean;
        icmpMbpsLimit: number;
        nullConnEnable: boolean;
        otherMbpsLimit: number;
        sConnLimit: number;
        sNewLimit: number;
        synLimit: number;
        synRate: number;
        tcpMbpsLimit: number;
        udpMbpsLimit: number;
    }

    export interface DdosPoliciesListPacketFilter {
        action: string;
        dEndPort: number;
        dStartPort: number;
        depth: number;
        isInclude: boolean;
        matchBegin: string;
        matchStr: string;
        matchType: string;
        offset: number;
        pktLengthMax: number;
        pktLengthMin: number;
        protocol: string;
        sEndPort: number;
        sStartPort: number;
    }

    export interface DdosPoliciesListPortFilter {
        action: string;
        endPort: number;
        kind: number;
        protocol: string;
        startPort: number;
    }

    export interface DdosPoliciesListWatermarkFilter {
        autoRemove: boolean;
        offset: number;
        openSwitch: boolean;
        tcpPortLists: string[];
        udpPortLists: string[];
    }

    export interface DdosPoliciesListWatermarkKey {
        content: string;
        createTime?: string;
        id: string;
        openSwitch: boolean;
    }

    export interface DdosPolicyAttachmentsDayuDdosPolicyAttachmentList {
        policyId: string;
        resourceId: string;
        resourceType: string;
    }

    export interface DdosPolicyCasesList {
        appProtocols: string[];
        appType: string;
        createTime: string;
        hasAbroad: string;
        hasInitiateTcp: string;
        hasInitiateUdp: string;
        hasVpn: string;
        maxTcpPackageLen: string;
        maxUdpPackageLen: string;
        minTcpPackageLen: string;
        minUdpPackageLen: string;
        name: string;
        peerTcpPort: string;
        peerUdpPort: string;
        platformTypes: string[];
        resourceType: string;
        sceneId: string;
        tcpEndPort: string;
        tcpFootprint: string;
        tcpStartPort: string;
        udpEndPort: string;
        udpFootprint: string;
        udpStartPort: string;
        webApiUrls: string[];
    }

    export interface DdosPolicyDropOption {
        badConnThreshold: number;
        checkSyncConn: boolean;
        connTimeout: number;
        dConnLimit: number;
        dNewLimit: number;
        dropAbroad: boolean;
        dropIcmp: boolean;
        dropOther: boolean;
        dropTcp: boolean;
        dropUdp: boolean;
        icmpMbpsLimit: number;
        nullConnEnable: boolean;
        otherMbpsLimit: number;
        sConnLimit: number;
        sNewLimit: number;
        synLimit: number;
        synRate?: number;
        tcpMbpsLimit: number;
        udpMbpsLimit: number;
    }

    export interface DdosPolicyPacketFilter {
        action?: string;
        dEndPort?: number;
        dStartPort?: number;
        depth?: number;
        isInclude?: boolean;
        matchBegin?: string;
        matchStr?: string;
        matchType?: string;
        offset?: number;
        pktLengthMax?: number;
        pktLengthMin?: number;
        protocol?: string;
        sEndPort?: number;
        sStartPort?: number;
    }

    export interface DdosPolicyPortFilter {
        action?: string;
        endPort?: number;
        kind?: number;
        protocol?: string;
        startPort?: number;
    }

    export interface DdosPolicyV2Acl {
        action: string;
        dPortEnd: number;
        dPortStart: number;
        forwardProtocol: string;
        priority: number;
        sPortEnd: number;
        sPortStart: number;
    }

    export interface DdosPolicyV2BlackWhiteIp {
        ip: string;
        ipType: string;
    }

    export interface DdosPolicyV2DdosConnectLimit {
        badConnThreshold: number;
        connTimeout: number;
        dstConnLimit: number;
        dstNewLimit: number;
        nullConnEnable: number;
        sdConnLimit: number;
        sdNewLimit: number;
        synLimit: number;
        synRate: number;
    }

    export interface DdosPolicyV2DdosGeoIpBlockConfig {
        action: string;
        areaLists: number[];
        regionType: string;
    }

    export interface DdosPolicyV2DdosSpeedLimitConfig {
        bandwidth: number;
        dstPortList: string;
        mode: number;
        packetRate: number;
        protocolList: string;
    }

    export interface DdosPolicyV2PacketFilter {
        action: string;
        dPortEnd: number;
        dPortStart: number;
        depth: number;
        depth2: number;
        isNot: number;
        isNot2: number;
        matchBegin: string;
        matchBegin2: string;
        matchLogic: string;
        matchType: string;
        matchType2: string;
        offset: number;
        offset2: number;
        pktlenMax: number;
        pktlenMin: number;
        protocol: string;
        sPortEnd: number;
        sPortStart: number;
        str: string;
        str2: string;
    }

    export interface DdosPolicyV2ProtocolBlockConfig {
        dropIcmp: number;
        dropOther: number;
        dropTcp: number;
        dropUdp: number;
    }

    export interface DdosPolicyWatermarkFilter {
        autoRemove?: boolean;
        offset?: number;
        openSwitch?: boolean;
        tcpPortLists?: string[];
        udpPortLists?: string[];
    }

    export interface DdosPolicyWatermarkKey {
        content: string;
        createTime?: string;
        id: string;
        openSwitch: boolean;
    }

    export interface L4RuleSourceList {
        source: string;
        weight: number;
    }

    export interface L4RuleV2Rules {
        keepEnable: boolean;
        keeptime: number;
        lbType: number;
        protocol: string;
        region: number;
        removeSwitch: boolean;
        ruleName: string;
        sourceLists: outputs.Dayu.L4RuleV2RulesSourceList[];
        sourcePort: number;
        sourceType: number;
        virtualPort: number;
    }

    export interface L4RuleV2RulesSourceList {
        source: string;
        weight: number;
    }

    export interface L4RulesList {
        dPort: number;
        healthCheckHealthNum: number;
        healthCheckInterval: number;
        healthCheckSwitch: boolean;
        healthCheckTimeout: number;
        healthCheckUnhealthNum: number;
        lbType: number;
        name: string;
        protocol: string;
        ruleId: string;
        sPort: number;
        sessionSwitch: boolean;
        sessionTime: number;
        sourceLists: outputs.Dayu.L4RulesListSourceList[];
        sourceType: number;
    }

    export interface L4RulesListSourceList {
        source: string;
        weight: number;
    }

    export interface L4RulesV2List {
        id: string;
        ip: string;
        keepEnable: boolean;
        keeptime: number;
        lbType: number;
        modifyTime: string;
        protocol: string;
        region: number;
        removeSwitch: boolean;
        ruleId: string;
        ruleName: string;
        sourceLists: outputs.Dayu.L4RulesV2ListSourceList[];
        sourcePort: number;
        sourceType: number;
        virtualPort: number;
    }

    export interface L4RulesV2ListSourceList {
        source: string;
        weight: number;
    }

    export interface L7RuleV2Rule {
        ccEnable?: number;
        certType?: number;
        domain: string;
        httpsToHttpEnable?: number;
        keepEnable: number;
        keeptime: number;
        lbType: number;
        protocol: string;
        sourceLists: outputs.Dayu.L7RuleV2RuleSourceList[];
        sourceType: number;
        sslId?: string;
    }

    export interface L7RuleV2RuleSourceList {
        source: string;
        weight: number;
    }

    export interface L7RulesList {
        domain: string;
        healthCheckCode: number;
        healthCheckHealthNum: number;
        healthCheckInterval: number;
        healthCheckMethod: string;
        healthCheckPath: string;
        healthCheckSwitch: boolean;
        healthCheckUnhealthNum: number;
        name: string;
        protocol: string;
        ruleId: string;
        sourceLists: string[];
        sourceType: number;
        sslId: string;
        status: number;
        switch: boolean;
        threshold: number;
    }

    export interface L7RulesV2List {
        ccEnable: number;
        ccLevel: string;
        ccStatus: number;
        ccThreshold: number;
        certType: number;
        domain: string;
        httpsToHttpEnable: number;
        id: string;
        ip: string;
        keepEnable: number;
        keepTime: number;
        lbType: number;
        modifyTime: string;
        protocol: string;
        region: number;
        ruleName: string;
        sourceLists: outputs.Dayu.L7RulesV2ListSourceList[];
        sourceType: number;
        sslId: string;
        status: number;
        virtualPort: number;
    }

    export interface L7RulesV2ListSourceList {
        source: string;
        weight: number;
    }

}

export namespace Dc {
    export interface GatewayCCNRoutesInstanceList {
        asPaths: string[];
        cidrBlock: string;
        dcgId: string;
        routeId: string;
    }

    export interface GatewayInstancesInstanceList {
        cnnRouteType: string;
        createTime: string;
        dcgId: string;
        dcgIp: string;
        enableBgp: boolean;
        gatewayType: string;
        name: string;
        networkInstanceId: string;
        networkType: string;
    }

    export interface InstancesInstanceList {
        accessPointId: string;
        bandwidth: number;
        circuitCode: string;
        createTime: string;
        customerAddress: string;
        customerEmail: string;
        customerName: string;
        customerPhone: string;
        dcId: string;
        enabledTime: string;
        expiredTime: string;
        faultReportContactPerson: string;
        faultReportContactPhone: string;
        lineOperator: string;
        location: string;
        name: string;
        portType: string;
        redundantDcId: string;
        state: string;
        tencentAddress: string;
    }

}

export namespace Dcx {
    export interface InstancesInstanceList {
        bandwidth: number;
        bgpAsn: number;
        bgpAuthKey: string;
        createTime: string;
        customerAddress: string;
        dcId: string;
        dcgId: string;
        dcxId: string;
        name: string;
        networkRegion: string;
        networkType: string;
        routeFilterPrefixes: string[];
        routeType: string;
        state: string;
        tencentAddress: string;
        vlan: number;
        vpcId: string;
    }

}

export namespace Dnats {
    export interface InstancesDnatList {
        description?: string;
        elasticIp: string;
        elasticPort: string;
        natId: string;
        privateIp: string;
        privatePort: string;
        protocol: string;
        vpcId: string;
    }

}

export namespace Eip {
    export interface InstancesFilter {
        name: string;
        values: string[];
    }

}

export namespace Eips {
    export interface InstancesEipList {
        createTime: string;
        eipId: string;
        eipName: string;
        eipType: string;
        eniId: string;
        instanceId: string;
        publicIp: string;
        status: string;
        tags: {[key: string]: any};
    }

}

export namespace Eks {
    export interface ClusterCredentialAddress {
        ip: string;
        port: string;
        type: string;
    }

    export interface ClusterCredentialInternalLb {
        enabled: boolean;
        subnetId: string;
    }

    export interface ClusterCredentialPublicLb {
        allowFromCidrs: string[];
        enabled: boolean;
        extraParam: string;
        securityGroup: string;
        securityPolicies: string[];
    }

    export interface ClusterDnsServer {
        domain?: string;
        servers?: string[];
    }

    export interface ClusterInternalLb {
        enabled: boolean;
        subnetId?: string;
    }

    export interface ClusterPublicLb {
        allowFromCidrs?: string[];
        enabled: boolean;
        extraParam?: string;
        securityGroup: string;
        securityPolicies?: string[];
    }

    export interface ClustersList {
        clusterDesc: string;
        clusterId: string;
        clusterName: string;
        createdTime: string;
        dnsServers: outputs.Eks.ClustersListDnsServer[];
        enableVpcCoreDns: boolean;
        k8sVersion: string;
        needDeleteCbs: boolean;
        serviceSubnetId: string;
        status: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface ClustersListDnsServer {
        domain: string;
        servers: string[];
    }

    export interface ContainerInstanceCbsVolume {
        diskId: string;
        name: string;
    }

    export interface ContainerInstanceContainer {
        args?: string[];
        commands?: string[];
        cpu?: number;
        envVars?: {[key: string]: any};
        image: string;
        livenessProbe?: outputs.Eks.ContainerInstanceContainerLivenessProbe;
        memory?: number;
        name: string;
        readinessProbe?: outputs.Eks.ContainerInstanceContainerReadinessProbe;
        volumeMounts?: outputs.Eks.ContainerInstanceContainerVolumeMount[];
        workingDir?: string;
    }

    export interface ContainerInstanceContainerLivenessProbe {
        execCommands?: string[];
        failureThreshold?: number;
        httpGetPath?: string;
        httpGetPort?: number;
        httpGetScheme?: string;
        initDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocketPort?: number;
        timeoutSeconds?: number;
    }

    export interface ContainerInstanceContainerReadinessProbe {
        execCommands?: string[];
        failureThreshold?: number;
        httpGetPath?: string;
        httpGetPort?: number;
        httpGetScheme?: string;
        initDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocketPort?: number;
        timeoutSeconds?: number;
    }

    export interface ContainerInstanceContainerVolumeMount {
        mountPropagation?: string;
        name: string;
        path: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
    }

    export interface ContainerInstanceImageRegistryCredential {
        name?: string;
        password?: string;
        server?: string;
        username?: string;
    }

    export interface ContainerInstanceInitContainer {
        args?: string[];
        commands?: string[];
        cpu?: number;
        envVars?: {[key: string]: any};
        image: string;
        memory?: number;
        name: string;
        volumeMounts?: outputs.Eks.ContainerInstanceInitContainerVolumeMount[];
        workingDir?: string;
    }

    export interface ContainerInstanceInitContainerVolumeMount {
        mountPropagation?: string;
        name: string;
        path: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
    }

    export interface ContainerInstanceNfsVolume {
        name: string;
        path: string;
        readOnly?: boolean;
        server: string;
    }

}

export namespace Elasticsearch {
    export interface InstanceMultiZoneInfo {
        availabilityZone: string;
        subnetId: string;
    }

    export interface InstanceNodeInfoList {
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        nodeNum: number;
        nodeType: string;
        type?: string;
    }

    export interface InstanceWebNodeTypeInfo {
        nodeNum: number;
        nodeType: string;
    }

    export interface InstancesInstanceList {
        availabilityZone: string;
        basicSecurityType: number;
        chargeType: string;
        createTime: string;
        deployMode: number;
        elasticsearchDomain: string;
        elasticsearchPort: number;
        elasticsearchVip: string;
        instanceId: string;
        instanceName: string;
        kibanaUrl: string;
        licenseType: string;
        multiZoneInfos: outputs.Elasticsearch.InstancesInstanceListMultiZoneInfo[];
        nodeInfoLists: outputs.Elasticsearch.InstancesInstanceListNodeInfoList[];
        subnetId: string;
        tags: {[key: string]: any};
        version: string;
        vpcId: string;
    }

    export interface InstancesInstanceListMultiZoneInfo {
        availabilityZone: string;
        subnetId: string;
    }

    export interface InstancesInstanceListNodeInfoList {
        diskSize: number;
        diskType: string;
        encrypt: boolean;
        nodeNum: number;
        nodeType: string;
        type: string;
    }

}

export namespace Emr {
    export interface ClusterResourceSpec {
        commonCount?: number;
        commonResourceSpec?: outputs.Emr.ClusterResourceSpecCommonResourceSpec;
        coreCount?: number;
        coreResourceSpec?: outputs.Emr.ClusterResourceSpecCoreResourceSpec;
        masterCount?: number;
        masterResourceSpec?: outputs.Emr.ClusterResourceSpecMasterResourceSpec;
        taskCount?: number;
        taskResourceSpec?: outputs.Emr.ClusterResourceSpecTaskResourceSpec;
    }

    export interface ClusterResourceSpecCommonResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecCoreResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecMasterResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecTaskResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface InstancesCluster {
        addTime: string;
        chargeType: number;
        clusterId: string;
        clusterName: string;
        ftitle: string;
        id: number;
        masterIp: string;
        projectId: number;
        regionId: number;
        status: number;
        zone: string;
        zoneId: number;
    }

    export interface NodesNode {
        appId: number;
        applyTime: string;
        autoFlag: number;
        cdbIp: string;
        cdbNodeInfos: outputs.Emr.NodesNodeCdbNodeInfo[];
        cdbPort: number;
        chargeType: number;
        cpuNum: number;
        destroyable: number;
        deviceClass: string;
        diskSize: string;
        dynamicPodSpec: string;
        emrResourceId: string;
        expireTime: string;
        flag: number;
        freeTime: string;
        hardwareResourceType: string;
        hwDiskSize: number;
        hwDiskSizeDesc: string;
        hwMemSize: number;
        hwMemSizeDesc: string;
        ip: string;
        isAutoRenew: number;
        isDynamicSpec: number;
        mcMultiDisks: outputs.Emr.NodesNodeMcMultiDisk[];
        memDesc: string;
        memSize: number;
        mutable: number;
        nameTag: string;
        orderNo: string;
        regionId: number;
        rootSize: number;
        serialNo: string;
        services: string;
        spec: string;
        storageType: number;
        supportModifyPayMode: number;
        tags: outputs.Emr.NodesNodeTag[];
        wanIp: string;
        zoneId: number;
    }

    export interface NodesNodeCdbNodeInfo {
        applyTime: string;
        expireFlag: boolean;
        expireTime: string;
        instanceName: string;
        ip: string;
        isAutoRenew: number;
        memSize: number;
        payType: number;
        port: number;
        regionId: number;
        serialNo: string;
        service: string;
        status: number;
        volume: number;
        zoneId: number;
    }

    export interface NodesNodeMcMultiDisk {
        count: number;
        type: number;
        volume: number;
    }

    export interface NodesNodeTag {
        tagKey: string;
        tagValue: string;
    }

}

export namespace Eni {
    export interface InstanceIpv4 {
        description?: string;
        ip: string;
        primary: boolean;
    }

    export interface InstanceIpv4Info {
        description: string;
        ip: string;
        primary: boolean;
    }

}

export namespace Enis {
    export interface InstancesEni {
        createTime: string;
        description: string;
        id: string;
        instanceId: string;
        ipv4s: outputs.Enis.InstancesEniIpv4[];
        mac: string;
        name: string;
        primary: boolean;
        securityGroups: string[];
        state: string;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface InstancesEniIpv4 {
        description: string;
        ip: string;
        primary: boolean;
    }

}

export namespace Gaap {
    export interface CertificatesCertificate {
        beginTime: string;
        createTime: string;
        endTime: string;
        id: string;
        issuerCn: string;
        name: string;
        subjectCn: string;
        type: string;
    }

    export interface DomainErrorPageInfoListErrorPageInfoList {
        body: string;
        clearHeaders: string[];
        domain: string;
        errorCodes: number[];
        id: string;
        listenerId: string;
        newErrorCodes: number;
        setHeaders: {[key: string]: any};
    }

    export interface HttpDomainsDomain {
        basicAuth: boolean;
        basicAuthId: string;
        certificateId: string;
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `client_certificate_ids` instead.
         */
        clientCertificateId: string;
        clientCertificateIds: string[];
        domain: string;
        gaapAuth: boolean;
        gaapAuthId: string;
        realserverAuth: boolean;
        realserverCertificateDomain: string;
        /**
         * @deprecated It has been deprecated from version 1.28.0. Use `realserver_certificate_ids` instead.
         */
        realserverCertificateId: string;
        realserverCertificateIds: string[];
    }

    export interface HttpRuleRealserver {
        id: string;
        ip: string;
        port: number;
        weight?: number;
    }

    export interface HttpRulesRule {
        connectTimeout: number;
        domain: string;
        forwardHost: string;
        healthCheck: boolean;
        healthCheckMethod: string;
        healthCheckPath: string;
        healthCheckStatusCodes: number[];
        id: string;
        interval: number;
        listenerId: string;
        path: string;
        realserverType: string;
        realservers: outputs.Gaap.HttpRulesRuleRealserver[];
        scheduler: string;
        sni: string;
        sniSwitch: string;
    }

    export interface HttpRulesRuleRealserver {
        domain: string;
        id: string;
        ip: string;
        port: number;
        status: number;
        weight: number;
    }

    export interface Layer4ListenerRealserverBindSet {
        id: string;
        ip: string;
        port: number;
        weight?: number;
    }

    export interface Layer4ListenersListener {
        connectTimeout: number;
        createTime: string;
        healthCheck: boolean;
        id: string;
        interval: number;
        name: string;
        port: number;
        protocol: string;
        realserverType: string;
        scheduler: string;
        status: number;
    }

    export interface Layer7ListenersListener {
        authType: number;
        certificateId: string;
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `client_certificate_ids` instead.
         */
        clientCertificateId: string;
        clientCertificateIds: string[];
        createTime: string;
        forwardProtocol: string;
        id: string;
        name: string;
        port: number;
        protocol: string;
        status: number;
    }

    export interface ProxiesProxy {
        accessRegion: string;
        bandwidth: number;
        concurrent: number;
        createTime: string;
        domain: string;
        forwardIp: string;
        id: string;
        ip: string;
        name: string;
        policyId: string;
        projectId: number;
        realserverRegion: string;
        scalable: boolean;
        status: string;
        supportProtocols: string[];
        tags: {[key: string]: any};
        version: string;
    }

    export interface RealserversRealserver {
        domain: string;
        id: string;
        ip: string;
        name: string;
        projectId: number;
        tags: {[key: string]: any};
    }

    export interface SecurityRulesRule {
        action: string;
        cidrIp: string;
        id: string;
        name: string;
        port: string;
        protocol: string;
    }

}

export namespace Ha {
    export interface VipEipAttachmentsHaVipEipAttachmentList {
        addressIp: string;
        havipId: string;
    }

    export interface VipsHaVipList {
        addressIp: string;
        createTime: string;
        id: string;
        instanceId: string;
        name: string;
        networkInterfaceId: string;
        state: string;
        subnetId: string;
        vip: string;
        vpcId: string;
    }

}

export namespace Instances {
    export interface InstancesInstanceList {
        allocatePublicIp: boolean;
        availabilityZone: string;
        camRoleName: string;
        cpu: number;
        createTime: string;
        dataDisks: outputs.Instances.InstancesInstanceListDataDisk[];
        expiredTime: string;
        imageId: string;
        instanceChargeType: string;
        instanceChargeTypePrepaidRenewFlag: string;
        instanceId: string;
        instanceName: string;
        instanceType: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        memory: number;
        privateIp: string;
        projectId: number;
        publicIp: string;
        securityGroups: string[];
        status: string;
        subnetId: string;
        systemDiskId: string;
        systemDiskSize: number;
        systemDiskType: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface InstancesInstanceListDataDisk {
        dataDiskId: string;
        dataDiskSize: number;
        dataDiskType: string;
        deleteWithInstance: boolean;
    }

}

export namespace Key {
    export interface PairsKeyPairList {
        createTime: string;
        keyId: string;
        keyName: string;
        projectId: number;
        publicKey: string;
    }

}

export namespace Kms {
    export interface KeysKeyList {
        alias: string;
        createTime: number;
        creatorUin: number;
        deletionDate: number;
        description: string;
        keyId: string;
        keyRotationEnabled: boolean;
        keyState: string;
        keyUsage: string;
        nextRotateTime: number;
        origin: string;
        owner: string;
        validTo: number;
    }

}

export namespace Mongodb {
    export interface InstanceStandbyInstanceList {
        standbyInstanceId: string;
        standbyInstanceRegion: string;
    }

    export interface InstancesInstanceList {
        autoRenewFlag: number;
        availableZone: string;
        chargeType: string;
        clusterType: string;
        cpu: number;
        createTime: string;
        engineVersion: string;
        instanceId: string;
        instanceName: string;
        machineType: string;
        memory: number;
        projectId: number;
        shardQuantity: number;
        status: number;
        subnetId: string;
        tags: {[key: string]: any};
        vip: string;
        volume: number;
        vpcId: string;
        vport: number;
    }

    export interface ZoneConfigList {
        availableZone: string;
        clusterType: string;
        cpu: number;
        defaultStorage: number;
        engineVersion: string;
        machineType: string;
        maxReplicateSetNum: number;
        maxStorage: number;
        memory: number;
        minReplicateSetNum: number;
        minStorage: number;
    }

}

export namespace Monitor {
    export interface AlarmPolicyConditions {
        isUnionRule?: number;
        rules?: outputs.Monitor.AlarmPolicyConditionsRule[];
    }

    export interface AlarmPolicyConditionsRule {
        continuePeriod: number;
        description: string;
        filter?: outputs.Monitor.AlarmPolicyConditionsRuleFilter;
        isPowerNotice: number;
        metricName?: string;
        noticeFrequency: number;
        operator?: string;
        period?: number;
        ruleType: string;
        unit: string;
        value?: string;
    }

    export interface AlarmPolicyConditionsRuleFilter {
        dimensions?: string;
        type?: string;
    }

    export interface AlarmPolicyEventCondition {
        continuePeriod: number;
        description: string;
        filter?: outputs.Monitor.AlarmPolicyEventConditionFilter;
        isPowerNotice: number;
        metricName?: string;
        noticeFrequency: number;
        operator?: string;
        period?: number;
        ruleType: string;
        unit: string;
        value?: string;
    }

    export interface AlarmPolicyEventConditionFilter {
        dimensions?: string;
        type?: string;
    }

    export interface AlarmPolicyPolicyTag {
        key: string;
        value: string;
    }

    export interface AlarmPolicyTriggerTask {
        taskConfig: string;
        type: string;
    }

    export interface BindingAlarmReceiverReceivers {
        endTime?: number;
        notifyWays: string[];
        receiveLanguage?: string;
        receiverGroupLists?: number[];
        receiverType: string;
        receiverUserLists?: number[];
        startTime?: number;
    }

    export interface BindingObjectDimension {
        dimensionsJson: string;
        uniqueId: string;
    }

    export interface BindingObjectsList {
        dimensionsJson: string;
        isShielded: number;
        region: string;
        uniqueId: string;
    }

    export interface DataDimension {
        name: string;
        value: string;
    }

    export interface DataList {
        timestamp: number;
        value: number;
    }

    export interface PolicyBindingObjectDimension {
        dimensionsJson: string;
        uniqueId: string;
    }

    export interface PolicyConditionsList {
        eventMetrics: outputs.Monitor.PolicyConditionsListEventMetric[];
        isSupportMultiRegion: boolean;
        metrics: outputs.Monitor.PolicyConditionsListMetric[];
        name: string;
        policyViewName: string;
        supportRegions: string[];
    }

    export interface PolicyConditionsListEventMetric {
        eventId: number;
        eventShowName: string;
        needRecovered: boolean;
    }

    export interface PolicyConditionsListMetric {
        calcTypeKeys: number[];
        calcTypeNeed: boolean;
        calcValueDefault: string;
        calcValueFixed: string;
        calcValueMax: string;
        calcValueMin: string;
        calcValueNeed: boolean;
        continueTimeDefault: number;
        continueTimeKeys: number[];
        continueTimeNeed: boolean;
        metricId: number;
        metricShowName: string;
        metricUnit: string;
        periodDefault: number;
        periodKeys: number[];
        periodNeed: boolean;
        periodNumDefault: number;
        periodNumKeys: number[];
        periodNumNeed: boolean;
        statTypeP10: string;
        statTypeP1800: string;
        statTypeP300: string;
        statTypeP3600: string;
        statTypeP5: string;
        statTypeP60: string;
        statTypeP600: string;
        statTypeP86400: string;
    }

    export interface PolicyGroupBindingObject {
        dimensionsJson: string;
        isShielded: number;
        region: string;
        uniqueId: string;
    }

    export interface PolicyGroupCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        calcPeriod: number;
        calcType: number;
        calcValue: number;
        continuePeriod: number;
        metricId: number;
    }

    export interface PolicyGroupEventCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        eventId: number;
    }

    export interface PolicyGroupReceiver {
        endTime: number;
        needSendNotice: number;
        notifyWays: string[];
        personInterval: number;
        receiveLanguage: string;
        receiverGroupLists: number[];
        receiverType: string;
        receiverUserLists: number[];
        recoverNotifies: string[];
        roundInterval: number;
        roundNumber: number;
        sendFors: string[];
        startTime: number;
        uidLists: number[];
    }

    export interface PolicyGroupsList {
        canSetDefault: boolean;
        conditions: outputs.Monitor.PolicyGroupsListCondition[];
        eventConditions: outputs.Monitor.PolicyGroupsListEventCondition[];
        groupId: number;
        groupName: string;
        insertTime: number;
        isDefault: number;
        isOpen: boolean;
        lastEditUin: string;
        noShieldedSum: number;
        parentGroupId: number;
        policyViewName: string;
        projectId: number;
        receivers: outputs.Monitor.PolicyGroupsListReceiver[];
        remark: string;
        updateTime: number;
        useSum: number;
    }

    export interface PolicyGroupsListCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        calcType: number;
        calcValue: string;
        continueTime: number;
        metricId: number;
        metricShowName: string;
        metricUnit: string;
        period: number;
        ruleId: number;
    }

    export interface PolicyGroupsListEventCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        eventId: number;
        eventShowName: string;
        ruleId: number;
    }

    export interface PolicyGroupsListReceiver {
        endTime: number;
        needSendNotice: number;
        notifyWays: string[];
        personInterval: number;
        receiveLanguage: string;
        receiverGroupLists: number[];
        receiverType: string;
        receiverUserLists: number[];
        recoverNotifies: string[];
        roundInterval: number;
        roundNumber: number;
        sendFors: string[];
        startTime: number;
        uidLists: number[];
    }

    export interface ProductEventDimension {
        name?: string;
        value?: string;
    }

    export interface ProductEventList {
        additionMsgs: outputs.Monitor.ProductEventListAdditionMsg[];
        dimensions: outputs.Monitor.ProductEventListDimension[];
        eventCname: string;
        eventEname: string;
        eventId: number;
        eventName: string;
        groupInfos: outputs.Monitor.ProductEventListGroupInfo[];
        instanceId: string;
        instanceName: string;
        isAlarmConfig: number;
        productCname: string;
        productEname: string;
        productName: string;
        projectId: string;
        region: string;
        startTime: number;
        status: string;
        supportAlarm: number;
        type: string;
        updateTime: number;
    }

    export interface ProductEventListAdditionMsg {
        key: string;
        name: string;
        value: string;
    }

    export interface ProductEventListDimension {
        key: string;
        name: string;
        value: string;
    }

    export interface ProductEventListGroupInfo {
        groupId: string;
        groupName: string;
    }

    export interface ProductNamespaceList {
        namespace: string;
        productChineseName: string;
        productName: string;
    }

}

export namespace Mysql {
    export interface BackupListList {
        backupId: number;
        backupModel: string;
        creator: string;
        finishTime: string;
        internetUrl: string;
        intranetUrl: string;
        size: number;
        time: string;
    }

    export interface DefaultParamsParamList {
        currentValue: string;
        default: string;
        description: string;
        enumValues: string[];
        max: number;
        min: number;
        name: string;
        needReboot: number;
        paramType: string;
    }

    export interface InstancesInstanceList {
        autoRenewFlag: number;
        chargeType: string;
        cpuCoreCount: number;
        createTime: string;
        deadLineTime: string;
        deviceType: string;
        drInstanceIds: string[];
        engineVersion: string;
        initFlag: number;
        instanceName: string;
        instanceRole: string;
        internetHost: string;
        internetPort: number;
        internetStatus: number;
        intranetIp: string;
        intranetPort: number;
        masterInstanceId: string;
        memorySize: number;
        mysqlId: string;
        payType: number;
        projectId: number;
        roInstanceIds: string[];
        slaveSyncMode: number;
        status: number;
        subnetId: string;
        volumeSize: number;
        vpcId: string;
        zone: string;
    }

    export interface ParameterListParameterList {
        currentValue: string;
        defaultValue: string;
        description: string;
        enumValues: string[];
        max: number;
        min: number;
        needReboot: number;
        parameterName: string;
        parameterType: string;
    }

    export interface PrivilegeColumn {
        columnName: string;
        databaseName: string;
        privileges: string[];
        tableName: string;
    }

    export interface PrivilegeDatabase {
        databaseName: string;
        privileges: string[];
    }

    export interface PrivilegeTable {
        databaseName: string;
        privileges: string[];
        tableName: string;
    }

    export interface ZoneConfigList {
        disasterRecoveryZones: string[];
        engineVersions: string[];
        firstSlaveZones: string[];
        hourInstanceSaleMaxNum: number;
        isDefault: number;
        isSupportDisasterRecovery: number;
        isSupportVpc: number;
        name: string;
        payTypes: number[];
        remoteRoZones: string[];
        secondSlaveZones: string[];
        sells: outputs.Mysql.ZoneConfigListSell[];
        slaveDeployModes: number[];
        supportSlaveSyncModes: number[];
    }

    export interface ZoneConfigListSell {
        cdbType: string;
        maxVolumeSize: number;
        memSize: number;
        minVolumeSize: number;
        qps: number;
        volumeStep: number;
    }

}

export namespace Nat {
    export interface GatewaySnatsSnatList {
        createTime: string;
        description: string;
        instanceId?: string;
        instancePrivateIpAddr?: string;
        natGatewayId: string;
        publicIpAddrs: string[];
        resourceType: string;
        snatId: string;
        subnetCidrBlock?: string;
        subnetId?: string;
    }

    export interface GatewaysNat {
        assignedEipSets: string[];
        bandwidth: number;
        createTime: string;
        id: string;
        maxConcurrent: number;
        name: string;
        state: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

}

export namespace Nats {
    export interface InstancesNat {
        assignedEipSets: string[];
        bandwidth: number;
        createTime: string;
        id: string;
        maxConcurrent: number;
        name: string;
        state: number;
        vpcId: string;
    }

}

export namespace Placement {
    export interface GroupsPlacementGroupList {
        createTime: string;
        currentNum: number;
        cvmQuotaTotal: number;
        instanceIds: string[];
        name: string;
        placementGroupId: string;
        type: string;
    }

}

export namespace Postgresql {
    export interface InstanceBackupPlan {
        backupPeriods?: string[];
        baseBackupRetentionPeriod?: number;
        maxBackupStartTime?: string;
        minBackupStartTime?: string;
    }

    export interface InstanceDbNodeSet {
        role?: string;
        zone: string;
    }

    export interface InstancesInstanceList {
        autoRenewFlag: number;
        availabilityZone: string;
        chargeType: string;
        charset: string;
        createTime: string;
        engineVersion: string;
        id: string;
        memory: number;
        name: string;
        privateAccessIp: string;
        privateAccessPort: number;
        projectId: number;
        publicAccessHost: string;
        publicAccessPort: number;
        publicAccessSwitch: boolean;
        rootUser: string;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface SpecinfosList {
        cpu: number;
        engineVersion: string;
        engineVersionName: string;
        id: string;
        memory: number;
        qps: number;
        storageMax: number;
        storageMin: number;
    }

    export interface XlogsList {
        endTime: string;
        externalAddr: string;
        id: number;
        internalAddr: string;
        size: number;
        startTime: string;
    }

}

export namespace PrivateDns {
    export interface ZoneAccountVpcSet {
        region: string;
        uin: string;
        uniqVpcId: string;
        vpcName: string;
    }

    export interface ZoneTagSet {
        tagKey: string;
        tagValue: string;
    }

    export interface ZoneVpcSet {
        region: string;
        uniqVpcId: string;
    }

}

export namespace Protocol {
    export interface TemplateGroupsGroupList {
        id: string;
        name: string;
        templateIds: string[];
    }

    export interface TemplatesTemplateList {
        id: string;
        name: string;
        protocols: string[];
    }

}

export namespace Redis {
    export interface InstancesInstanceList {
        chargeType: string;
        createTime: string;
        ip: string;
        memSize: number;
        name: string;
        nodeInfos: outputs.Redis.InstancesInstanceListNodeInfo[];
        port: number;
        projectId: number;
        redisId: string;
        redisReplicasNum: number;
        redisShardNum: number;
        status: string;
        subnetId: string;
        tags: {[key: string]: any};
        /**
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        typeId: number;
        vpcId: string;
        zone: string;
    }

    export interface InstancesInstanceListNodeInfo {
        id: number;
        master: boolean;
        zoneId: number;
    }

    export interface ZoneConfigList {
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `shard_memories` instead.
         */
        memSizes: number[];
        redisReplicasNums: number[];
        redisShardNums: number[];
        shardMemories: number[];
        /**
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        typeId: number;
        version: string;
        zone: string;
    }

}

export namespace Reserved {
    export interface InstancesReservedInstanceList {
        availabilityZone: string;
        endTime: string;
        instanceCount: number;
        instanceType: string;
        reservedInstanceId: string;
        startTime: string;
        status: string;
    }

}

export namespace Route {
    export interface TableRoute {
        cidrBlock: string;
        description: string;
        nextHub: string;
        nextType: string;
    }

}

export namespace Scf {
    export interface FunctionCfsConfig {
        cfsId: string;
        ipAddress: string;
        localMountDir: string;
        mountInsId: string;
        mountSubnetId: string;
        mountVpcId: string;
        remoteMountDir: string;
        userGroupId: string;
        userId: string;
    }

    export interface FunctionImageConfig {
        args?: string;
        command?: string;
        entryPoint?: string;
        imageType: string;
        imageUri: string;
        registryId?: string;
    }

    export interface FunctionLayer {
        layerName: string;
        layerVersion: number;
    }

    export interface FunctionTrigger {
        cosRegion?: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface FunctionTriggerInfo {
        createTime: string;
        customArgument: string;
        enable: boolean;
        modifyTime: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface FunctionsFunction {
        clsLogsetId: string;
        clsTopicId: string;
        codeError: string;
        codeResult: string;
        codeSize: number;
        createTime: string;
        description: string;
        eipFixed: boolean;
        eips: string[];
        enableEipConfig: boolean;
        enablePublicNet: boolean;
        environment: {[key: string]: any};
        errNo: number;
        handler: string;
        host: string;
        installDependency: boolean;
        l5Enable: boolean;
        memSize: number;
        modifyTime: string;
        name: string;
        namespace: string;
        role: string;
        runtime: string;
        status: string;
        statusDesc: string;
        subnetId: string;
        tags: {[key: string]: any};
        timeout: number;
        triggerInfos: outputs.Scf.FunctionsFunctionTriggerInfo[];
        vip: string;
        vpcId: string;
    }

    export interface FunctionsFunctionTriggerInfo {
        createTime: string;
        customArgument: string;
        enable: boolean;
        modifyTime: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface LayerContent {
        cosBucketName?: string;
        cosBucketRegion?: string;
        cosObjectName?: string;
        zipFile?: string;
    }

    export interface LogsLog {
        billDuration: number;
        duration: number;
        functionName: string;
        invokeFinished: number;
        level: string;
        log: string;
        memUsage: number;
        requestId: string;
        retCode: number;
        retMsg: string;
        source: string;
        startTime: string;
    }

    export interface NamespacesNamespace {
        createTime: string;
        description: string;
        modifyTime: string;
        namespace: string;
        type: string;
    }

}

export namespace Security {
    export interface GroupRuleAddressTemplate {
        groupId?: string;
        templateId?: string;
    }

    export interface GroupRuleProtocolTemplate {
        groupId?: string;
        templateId?: string;
    }

    export interface GroupsSecurityGroup {
        beAssociateCount: number;
        createTime: string;
        description: string;
        egresses: string[];
        ingresses: string[];
        name: string;
        projectId: number;
        securityGroupId: string;
        tags: {[key: string]: any};
    }

}

export namespace Sqlserver {
    export interface AccountDBAttachmentsList {
        accountName: string;
        dbName: string;
        instanceId: string;
        privilege: string;
    }

    export interface AccountsList {
        createTime: string;
        instanceId: string;
        name: string;
        remark: string;
        status: number;
        updateTime: string;
    }

    export interface BackupsList {
        dbLists: string[];
        endTime: string;
        fileName: string;
        id: string;
        instanceId: string;
        internetUrl: string;
        intranetUrl: string;
        size: number;
        startTime: string;
        status: number;
        strategy: number;
        triggerModel: number;
    }

    export interface BasicInstancesInstanceList {
        availabilityZone: string;
        chargeType: string;
        cpu: number;
        createTime: string;
        engineVersion: string;
        id: string;
        memory: number;
        name: string;
        projectId: number;
        status: number;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        usedStorage: number;
        vip: string;
        vpcId: string;
        vport: number;
    }

    export interface DBsDbList {
        charset: string;
        createTime: string;
        instanceId: string;
        name: string;
        remark: string;
        status: string;
    }

    export interface InstancesInstanceList {
        availabilityZone: string;
        chargeType: string;
        createTime: string;
        engineVersion: string;
        haType: string;
        id: string;
        memory: number;
        name: string;
        projectId: number;
        roFlag: string;
        status: number;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        usedStorage: number;
        vip: string;
        vpcId: string;
        vport: number;
    }

    export interface PublishSubscribeDatabaseTuple {
        publishDatabase: string;
    }

    export interface PublishSubscribesPublishSubscribeList {
        databaseTuples: outputs.Sqlserver.PublishSubscribesPublishSubscribeListDatabaseTuple[];
        publishInstanceId: string;
        publishInstanceIp: string;
        publishInstanceName: string;
        publishSubscribeId: number;
        publishSubscribeName: string;
        subscribeInstanceId: string;
        subscribeInstanceIp: string;
        subscribeInstanceName: string;
    }

    export interface PublishSubscribesPublishSubscribeListDatabaseTuple {
        lastSyncTime: string;
        publishDatabase: string;
        status: string;
        subscribeDatabase: string;
    }

    export interface ReadonlyGroupsList {
        id: string;
        isOfflineDelay: number;
        masterInstanceId: string;
        maxDelayTime: number;
        minInstances: number;
        name: string;
        readonlyInstanceSets: string[];
        status: number;
        vip: string;
        vport: number;
    }

    export interface ZoneConfigZoneList {
        availabilityZone: string;
        specinfoLists: outputs.Sqlserver.ZoneConfigZoneListSpecinfoList[];
        zoneId: number;
    }

    export interface ZoneConfigZoneListSpecinfoList {
        chargeType: string;
        cpu: number;
        dbVersion: string;
        dbVersionName: string;
        machineType: string;
        maxStorageSize: number;
        memory: number;
        minStorageSize: number;
        qps: number;
        specId: number;
    }

}

export namespace Ssl {
    export interface CertificatesCertificate {
        beginTime: string;
        cert: string;
        createTime: string;
        domain: string;
        endTime: string;
        id: string;
        name: string;
        productZhName: string;
        projectId: number;
        status: number;
        subjectNames: string[];
        type: string;
    }

    export interface InstanceInformation {
        adminEmail: string;
        adminFirstName: string;
        adminLastName: string;
        adminPhoneNum: string;
        adminPosition: string;
        certificateDomain: string;
        contactEmail: string;
        contactFirstName: string;
        contactLastName: string;
        contactNumber: string;
        contactPosition: string;
        csrContent?: string;
        csrType?: string;
        domainLists?: string[];
        keyPassword?: string;
        organizationAddress: string;
        organizationCity: string;
        organizationCountry: string;
        organizationDivision: string;
        organizationName: string;
        organizationRegion: string;
        phoneAreaCode: string;
        phoneNumber: string;
        postalCode: string;
        verifyType: string;
    }

}

export namespace Ssm {
    export interface SecretVersionsSecretVersionList {
        secretBinary: string;
        secretString: string;
        versionId: string;
    }

    export interface SecretsSecretList {
        createTime: number;
        createUin: number;
        deleteTime: number;
        description: string;
        kmsKeyId: string;
        secretName: string;
        status: string;
    }

}

export namespace Tcaplus {
    export interface ClustersList {
        apiAccessId: string;
        apiAccessIp: string;
        apiAccessPort: number;
        clusterId: string;
        clusterName: string;
        createTime: string;
        idlType: string;
        networkType: string;
        oldPasswordExpireTime: string;
        password: string;
        passwordStatus: string;
        subnetId: string;
        vpcId: string;
    }

    export interface IdlTableInfo {
        error: string;
        indexKeySet: string;
        keyFields: string;
        sumKeyFieldSize: number;
        sumValueFieldSize: number;
        tableName: string;
        valueFields: string;
    }

    export interface IdlsList {
        idlId: string;
    }

    export interface TableGroupsList {
        createTime: string;
        tableCount: number;
        tablegroupId: string;
        tablegroupName: string;
        totalSize: number;
    }

    export interface TablesList {
        createTime: string;
        description: string;
        error: string;
        idlId: string;
        reservedReadCu: number;
        reservedVolume: number;
        reservedWriteCu: number;
        status: string;
        tableId: string;
        tableIdlType: string;
        tableName: string;
        tableSize: number;
        tableType: string;
        tablegroupId: string;
    }

}

export namespace Tcr {
    export interface InstanceSecurityPolicy {
        cidrBlock?: string;
        description?: string;
        index: number;
        version: string;
    }

}

export namespace Tke {
    export interface AsScalingGroupAutoScalingConfig {
        configurationName: string;
        dataDisks?: outputs.Tke.AsScalingGroupAutoScalingConfigDataDisk[];
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        instanceTags?: {[key: string]: any};
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string[];
        password?: string;
        projectId?: number;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        systemDiskSize?: number;
        systemDiskType?: string;
    }

    export interface AsScalingGroupAutoScalingConfigDataDisk {
        diskSize?: number;
        diskType?: string;
        snapshotId?: string;
    }

    export interface AsScalingGroupAutoScalingGroup {
        defaultCooldown?: number;
        desiredCapacity: number;
        forwardBalancerIds?: outputs.Tke.AsScalingGroupAutoScalingGroupForwardBalancerId[];
        loadBalancerIds?: string[];
        maxSize: number;
        minSize: number;
        projectId?: number;
        retryPolicy?: string;
        scalingGroupName: string;
        subnetIds?: string[];
        tags?: {[key: string]: any};
        terminationPolicies?: string;
        vpcId: string;
        zones?: string[];
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        ruleId?: string;
        targetAttributes: outputs.Tke.AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute[];
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

    export interface ChartsChartList {
        label: {[key: string]: any};
        latestVersion: string;
        name: string;
    }

    export interface ClusterAttachmentWorkerConfig {
        dataDisks?: outputs.Tke.ClusterAttachmentWorkerConfigDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverrides {
        dataDisks?: outputs.Tke.ClusterAttachmentWorkerConfigOverridesDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverridesDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ClusterAuthOptions {
        autoCreateDiscoveryAnonymousAuth?: boolean;
        issuer?: string;
        jwksUri?: string;
    }

    export interface ClusterClusterAudit {
        enabled: boolean;
        logSetId?: string;
        topicId?: string;
    }

    export interface ClusterClusterExtraArgs {
        kubeApiservers?: string[];
        kubeControllerManagers?: string[];
        kubeSchedulers?: string[];
    }

    export interface ClusterCommonNamesList {
        commonNames: string;
        subaccountUin: string;
    }

    export interface ClusterEventPersistence {
        enabled: boolean;
        logSetId?: string;
        topicId?: string;
    }

    export interface ClusterExistInstance {
        desiredPodNumbers?: number[];
        instancesPara?: outputs.Tke.ClusterExistInstanceInstancesPara;
        nodeRole?: string;
    }

    export interface ClusterExistInstanceInstancesPara {
        instanceIds: string[];
    }

    export interface ClusterExtensionAddon {
        name: string;
        param: string;
    }

    export interface ClusterLevelsList {
        alias: string;
        configMapCount: number;
        crdCount: number;
        enable: boolean;
        name: string;
        nodeCount: number;
        otherCount: number;
        podCount: number;
    }

    export interface ClusterLogAgent {
        enabled: boolean;
        kubeletRootDir?: string;
    }

    export interface ClusterMasterConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Tke.ClusterMasterConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ClusterMasterConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ClusterNodePoolGlobalConfig {
        expander: string;
        ignoreDaemonSetsUtilization: boolean;
        isScaleInEnabled: boolean;
        maxConcurrentScaleIn: number;
        scaleInDelay: number;
        scaleInUnneededTime: number;
        scaleInUtilizationThreshold: number;
        skipNodesWithLocalStorage: boolean;
        skipNodesWithSystemPods: boolean;
    }

    export interface ClusterWorkerConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Tke.ClusterWorkerConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ClusterWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ClusterWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

    export interface ClustersList {
        certificationAuthority: string;
        claimExpiredSeconds: number;
        clusterAsEnabled: boolean;
        clusterCidr: string;
        clusterDeployType: string;
        clusterDesc: string;
        clusterExternalEndpoint: string;
        clusterExtraArgs: outputs.Tke.ClustersListClusterExtraArg[];
        clusterId: string;
        clusterIpvs: boolean;
        clusterMaxPodNum: number;
        clusterMaxServiceNum: number;
        clusterName: string;
        clusterNodeNum: number;
        clusterOs: string;
        clusterVersion: string;
        /**
         * @deprecated It has been deprecated from version 1.18.1.
         */
        containerRuntime: string;
        deletionProtection: boolean;
        domain: string;
        eniSubnetIds: string[];
        ignoreClusterCidrConflict: boolean;
        isNonStaticIpMode: boolean;
        kubeConfig: string;
        kubeConfigIntranet: string;
        kubeProxyMode: string;
        networkType: string;
        nodeNameType: string;
        password: string;
        pgwEndpoint: string;
        projectId: number;
        securityPolicies: string[];
        serviceCidr: string;
        tags: {[key: string]: any};
        userName: string;
        vpcId: string;
        workerInstancesLists: outputs.Tke.ClustersListWorkerInstancesList[];
    }

    export interface ClustersListClusterExtraArg {
        kubeApiservers: string[];
        kubeControllerManagers: string[];
        kubeSchedulers: string[];
    }

    export interface ClustersListWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

    export interface NodePoolAutoScalingConfig {
        backupInstanceTypes?: string[];
        bandwidthPackageId?: string;
        camRoleName?: string;
        dataDisks?: outputs.Tke.NodePoolAutoScalingConfigDataDisk[];
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        instanceChargeType: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string[];
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        spotInstanceType?: string;
        spotMaxPrice?: string;
        systemDiskSize?: number;
        systemDiskType?: string;
    }

    export interface NodePoolAutoScalingConfigDataDisk {
        deleteWithInstance?: boolean;
        diskSize?: number;
        diskType?: string;
        snapshotId?: string;
    }

    export interface NodePoolNodeConfig {
        dataDisks?: outputs.Tke.NodePoolNodeConfigDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface NodePoolNodeConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface NodePoolTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ScaleWorkerDataDisk {
        autoFormatAndMount?: boolean;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ScaleWorkerWorkerConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Tke.ScaleWorkerWorkerConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ScaleWorkerWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ScaleWorkerWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

}

export namespace Vod {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        audio: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoAudio;
        removeAudio?: boolean;
        video: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoVideo;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        audioChannel?: string;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        bitrate: number;
        codec: string;
        fillType?: string;
        fps: number;
        height?: number;
        resolutionAdaptive?: boolean;
        width?: number;
    }

    export interface AdaptiveDynamicStreamingTemplatesTemplateList {
        comment: string;
        createTime: string;
        definition: string;
        disableHigherVideoBitrate: boolean;
        disableHigherVideoResolution: boolean;
        drmType: string;
        format: string;
        name: string;
        streamInfos: outputs.Vod.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfo[];
        type: string;
        updateTime: string;
    }

    export interface AdaptiveDynamicStreamingTemplatesTemplateListStreamInfo {
        audios: outputs.Vod.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio[];
        removeAudio: boolean;
        videos: outputs.Vod.AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo[];
    }

    export interface AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio {
        audioChannel: string;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo {
        bitrate: number;
        codec: string;
        fillType: string;
        fps: number;
        height: number;
        resolutionAdaptive: boolean;
        width: number;
    }

    export interface ImageSpriteTemplatesTemplateList {
        columnCount: number;
        comment: string;
        createTime: string;
        definition: string;
        fillType: string;
        height: number;
        name: string;
        resolutionAdaptive: boolean;
        rowCount: number;
        sampleInterval: number;
        sampleType: string;
        type: string;
        updateTime: string;
        width: number;
    }

    export interface ProcedureTemplateMediaProcessTask {
        adaptiveDynamicStreamingTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        animatedGraphicTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList[];
        coverBySnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList[];
        imageSpriteTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskImageSpriteTaskList[];
        sampleSnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList[];
        snapshotByTimeOffsetTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        transcodeTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        definition: string;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList {
        definition: string;
        endTimeOffset: number;
        startTimeOffset: number;
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList {
        definition: string;
        positionType: string;
        positionValue: number;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskImageSpriteTaskList {
        definition: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList {
        definition: string;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList {
        definition: string;
        extTimeOffsetLists?: string[];
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskList {
        definition: string;
        mosaicLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList[];
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList {
        coordinateOrigin?: string;
        endTimeOffset?: number;
        height?: string;
        startTimeOffset?: number;
        width?: string;
        xPos?: string;
        yPos?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplatesTemplateList {
        comment: string;
        createTime: string;
        mediaProcessTasks: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTask[];
        name: string;
        type: string;
        updateTime: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTask {
        adaptiveDynamicStreamingTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        animatedGraphicTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList[];
        coverBySnapshotTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList[];
        imageSpriteTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList[];
        sampleSnapshotTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList[];
        snapshotByTimeOffsetTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        transcodeTaskLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        definition: string;
        watermarkLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList {
        definition: string;
        endTimeOffset: number;
        startTimeOffset: number;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList {
        definition: string;
        positionType: string;
        positionValue: number;
        watermarkLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList {
        definition: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList {
        definition: string;
        watermarkLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList {
        definition: string;
        extTimeOffsetLists: string[];
        watermarkLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList {
        definition: string;
        mosaicLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList[];
        watermarkLists: outputs.Vod.ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList {
        coordinateOrigin: string;
        endTimeOffset: number;
        height: string;
        startTimeOffset: number;
        width: string;
        xPos: string;
        yPos: string;
    }

    export interface ProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface SnapshotByTimeOffsetTemplatesTemplateList {
        comment: string;
        createTime: string;
        definition: string;
        fillType: string;
        format: string;
        height: number;
        name: string;
        resolutionAdaptive: boolean;
        type: string;
        updateTime: string;
        width: number;
    }

    export interface SuperPlayerConfigDrmStreamingInfo {
        simpleAesDefinition?: string;
    }

    export interface SuperPlayerConfigResolutionName {
        minEdgeLength: number;
        name: string;
    }

    export interface SuperPlayerConfigsConfigList {
        adaptiveDynamicStreamingDefinition: string;
        comment: string;
        createTime: string;
        domain: string;
        drmStreamingInfos: outputs.Vod.SuperPlayerConfigsConfigListDrmStreamingInfo[];
        drmSwitch: boolean;
        imageSpriteDefinition: string;
        name: string;
        resolutionNames: outputs.Vod.SuperPlayerConfigsConfigListResolutionName[];
        scheme: string;
        type: string;
        updateTime: string;
    }

    export interface SuperPlayerConfigsConfigListDrmStreamingInfo {
        simpleAesDefinition: string;
    }

    export interface SuperPlayerConfigsConfigListResolutionName {
        minEdgeLength: number;
        name: string;
    }

}

export namespace Vpc {
    export interface AclsAclList {
        createTime: string;
        egresses: outputs.Vpc.AclsAclListEgress[];
        id: string;
        ingresses: outputs.Vpc.AclsAclListIngress[];
        name: string;
        subnets: outputs.Vpc.AclsAclListSubnet[];
        vpcId: string;
    }

    export interface AclsAclListEgress {
        cidrBlock: string;
        description: string;
        policy: string;
        port: string;
        protocol: string;
    }

    export interface AclsAclListIngress {
        cidrBlock: string;
        description: string;
        policy: string;
        port: string;
        protocol: string;
    }

    export interface AclsAclListSubnet {
        cidrBlock: string;
        subnetId: string;
        subnetName: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface RouteTablesInstanceList {
        createTime: string;
        isDefault: boolean;
        name: string;
        routeEntryInfos: outputs.Vpc.RouteTablesInstanceListRouteEntryInfo[];
        routeTableId: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface RouteTablesInstanceListRouteEntryInfo {
        description: string;
        destinationCidrBlock: string;
        nextHub: string;
        nextType: string;
        routeEntryId: string;
    }

    export interface SubnetsInstanceList {
        availabilityZone: string;
        availableIpCount: number;
        cidrBlock: string;
        createTime: string;
        isDefault: boolean;
        isMulticast: boolean;
        name: string;
        routeTableId: string;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface VpcInstancesInstanceList {
        cidrBlock: string;
        createTime: string;
        dnsServers: string[];
        isDefault: boolean;
        isMulticast: boolean;
        name: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

}

export namespace Vpn {
    export interface ConnectionSecurityGroupPolicy {
        localCidrBlock: string;
        remoteCidrBlocks: string[];
    }

    export interface ConnectionsConnectionList {
        createTime: string;
        customerGatewayId: string;
        encryptProto: string;
        id: string;
        ikeDhGroupName: string;
        ikeExchangeMode: string;
        ikeLocalAddress: string;
        ikeLocalFqdnName: string;
        ikeLocalIdentity: string;
        ikeProtoAuthenAlgorithm: string;
        ikeProtoEncryAlgorithm: string;
        ikeRemoteAddress: string;
        ikeRemoteFqdnName: string;
        ikeRemoteIdentity: string;
        ikeSaLifetimeSeconds: number;
        ikeVersion: string;
        ipsecEncryptAlgorithm: string;
        ipsecIntegrityAlgorithm: string;
        ipsecPfsDhGroup: string;
        ipsecSaLifetimeSeconds: number;
        ipsecSaLifetimeTraffic: number;
        name: string;
        netStatus: string;
        preShareKey: string;
        routeType: string;
        securityGroupPolicies: outputs.Vpn.ConnectionsConnectionListSecurityGroupPolicy[];
        state: string;
        tags: {[key: string]: any};
        vpcId: string;
        vpnGatewayId: string;
        vpnProto: string;
    }

    export interface ConnectionsConnectionListSecurityGroupPolicy {
        localCidrBlock: string;
        remoteCidrBlocks: string[];
    }

    export interface CustomerGatewaysGatewayList {
        createTime: string;
        id: string;
        name: string;
        publicIpAddress: string;
        tags: {[key: string]: any};
    }

    export interface GatewayRoutesVpnGatewayRouteList {
        createTime: string;
        destinationCidrBlock: string;
        instanceId: string;
        instanceType: string;
        priority: number;
        routeId: string;
        status: string;
        type: string;
        updateTime: string;
        vpnGatewayId: string;
    }

    export interface GatewaysGatewayList {
        bandwidth: number;
        chargeType: string;
        createTime: string;
        expiredTime: string;
        id: string;
        isAddressBlocked: boolean;
        name: string;
        newPurchasePlan: string;
        prepaidRenewFlag: string;
        publicIpAddress: string;
        restrictState: string;
        state: string;
        tags: {[key: string]: any};
        type: string;
        vpcId: string;
        zone: string;
    }

}

export namespace config {
    export interface AssumeRole {
        policy?: string;
        roleArn: string;
        sessionDuration: number;
        sessionName: string;
    }

}
